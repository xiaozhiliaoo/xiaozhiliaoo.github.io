<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年尾声规划</title>
    <url>/2020/08/16/2020-plan/</url>
    <content><![CDATA[<p>2020年还有4个月就结束了，今年从疫情期间忙忙碌碌，时间过得飞快。想到了诸葛亮的诫子书一句话，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及。觉得很惭愧，思想提高慢，能力提高慢，技术深度提高慢，希望制定以下计划来日益精进自我的技术。</p>
<p>经过思考以下几个点需要不断提高：</p>
<ol>
<li>体系化思考，深度思考能力(欠缺)</li>
<li>提高技术鉴赏力，品味(一般)</li>
<li>算法能力(严重短板)</li>
<li>工程，架构以及软件设计能力(一般)</li>
<li>项目管理能力(欠缺)</li>
<li>英语读写，中文读写，文档能力(欠缺)</li>
<li>面试能力，BQ，面试题  (不满意)</li>
</ol>
]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>2020尾声规划</tag>
      </tags>
  </entry>
  <entry>
    <title>惊奇的工程算法简介</title>
    <url>/2021/01/03/Algorithm-Engineering/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本系列主要介绍比较经典/常用的工程算法，理解这些算法非常有意义，对于程序优化有很有帮助，会发出惊奇的感慨。这里算法以工程为出发点，而非严谨意义上的数学证明算法。</p>
<h1 id="工程算法分类"><a href="#工程算法分类" class="headerlink" title="工程算法分类"></a>工程算法分类</h1><p>算法主要分为以下几类：</p>
<h2 id="单机系统"><a href="#单机系统" class="headerlink" title="单机系统"></a>单机系统</h2><ol>
<li>Membership:   HashSet.constains, BitSet.get, Bloom Filter，Counting Bloom Filter</li>
<li>Cardinality:   HashSet.size, BitSet.cardinality, Linear counter，Log Log，HyperLogLog</li>
<li>Frequency: HashMap.put, HashMultiset.count, Count Sketch，Count-Min Sketch</li>
<li>Hash算法和一致性Hash算法</li>
<li>时间轮算法：Hashed and Hierarchical Timing Wheel</li>
<li>唯一ID生成器：snowflake，</li>
<li>负载均衡算法：Round robin，Weighted round robin</li>
<li>限流算法：Token Bucket，Leaky Bucket，Fixed Window，Sliding Log，Sliding Window</li>
<li>缓存淘汰算法：LFU，LRU，FIFO</li>
</ol>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ol>
<li>共识算法：ZAB，Paxos，Raft，Viewstamped Replication，PBFT，Atomic Broadcast</li>
<li>选举算法：Bully，Ring</li>
<li>快照算法：Chandy Lamport，Lightweight Asynchronous Snapshots</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>工程算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理Proxy的设计与实现</title>
    <url>/2020/11/21/Dynamic-Proxy/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Java动态代理实现是基于反射和动态生成Class文件的技术，Proxy，InvocationHandler，Method是三个核心类，Proxy是代理类的入口，用来获取代理类，创建代理实例，获取InvocationHandler，判断某个类是否是代理类，InvocationHandler是方法调用的拦截，invoke方法是接口唯一方法，Method是反射的方法，用来完成方法调用。</p>
<h1 id="案例看行为"><a href="#案例看行为" class="headerlink" title="案例看行为"></a>案例看行为</h1><p>我们先通过一个Person案例来看动态代理生成的代理类的模样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公共接口实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before invoke"</span>);</span><br><span class="line">        Object invoke = method.invoke(person, args);</span><br><span class="line">        System.out.println(<span class="string">"after invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成动态代理类文件</span></span><br><span class="line">        System.getProperties().put(<span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//通过Proxy.newProxyInstance创建动态代理类，并且转型成Person。Person本质是$Proxy0代理类。</span></span><br><span class="line">        Person person = (Person) Proxy.newProxyInstance(</span><br><span class="line">                Person<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), //类加载器</span></span><br><span class="line">                new Class[]&#123;Person.class&#125;,  //接口</span><br><span class="line">                <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> PersonImpl())  <span class="comment">//调用处理器</span></span><br><span class="line">        );</span><br><span class="line">        person.setName(<span class="string">"lili"</span>);<span class="comment">//动态代理类调用setName</span></span><br><span class="line">        System.out.println(person.getName());<span class="comment">//动态代理类调用getName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看下生成的$Proxy0类，该类是真正的代理类。分析可知：该类是final说明不可被子类化，并且继承Proxy的构造函数，这也就是Proxy构造函数为什么是protect的原因，同时实现了Person接口，说明代理类可以转型为Person，从而可以调用Person方法产生代理行为，在方法层面，所有的方法都是final方法。在$Proxy0 m0，m1，m2始终为hashCode，equals，toString方法，而m3，m4 …… 为目标接口的方法，我们可以看到当$Proxy0调用setName时候，实质调用了h.invoke(this, m4, new Object[]{var1})方法，也就是我们自定义的MyInvocationHandler#invoke方法，从而产生代理行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;<span class="comment">//hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;<span class="comment">//equals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;<span class="comment">//toString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;<span class="comment">//getName</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;<span class="comment">//setName</span></span><br><span class="line">    <span class="comment">//继承Proxy构造方法</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler param1) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取到method对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;      </span><br><span class="line">        m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">        m3 = Class.forName(<span class="string">"org.lili.jdk.lang.reflect.Person"</span>).getMethod(<span class="string">"getName"</span>);</span><br><span class="line">        m4 = Class.forName(<span class="string">"org.lili.jdk.lang.reflect.Person"</span>).getMethod(<span class="string">"setName"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>通过案例，我们可以勾画出动态代理的结构</p>
<p><img src="/images/Proxy.png" alt=""></p>
<p>$Proxy0作为Proxy，Person作为Subject，而PersonImpl作为RealSubject是和设计模式代理模式一模一样。</p>
<p><img src="/images/GOF-Proxy.png" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>java.lang.reflect</tag>
        <tag>Java-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletionService设计与实现</title>
    <url>/2020/11/13/CompletionService-Design-And-Implementation/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>使用ExecutorService时候，我们只是向其中不断提交任务，然后通过Future获取get任务结果，但是有时候get需要等待，虽然可行，但是比较繁琐，可以有更好的方式，比如CompletionService实现了将完成的任务放在完成队列中，使得获取任务结果可以向队列一样通过take和poll任务结果，这样比ExecutorService更加方便。CompletionService通过ExecutorCompletionService实现，这两个实现均非常简单。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><img src="/images/CompletionService.png" style="zoom:60%;" />

<p>通过类图，可以看出CompletionService并没有继承ExecutorService，而是内部包含了AbstractExecutorService类，CompletionService和ExecutorService比较类似地方是都有submit方法，而CompletionService获取执行结果是根据take和poll的方式去获取。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="任务结果排队的QueueingFuture"><a href="#任务结果排队的QueueingFuture" class="headerlink" title="任务结果排队的QueueingFuture"></a>任务结果排队的QueueingFuture</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全部final，说明在构造函数里面会创建好这些实例变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTask extension to enqueue upon completion.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task,</span><br><span class="line">                   BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.completionQueue = completionQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line">    <span class="comment">//FutureTask的钩子方法，用户任务结束时候的扩展，QueueingFuture继承了该方法，并将结束的</span></span><br><span class="line">    <span class="comment">//任务放入阻塞队列</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">        (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.completionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span> || completionQueue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">        (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.completionQueue = completionQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="提交任务submit"><a href="#提交任务submit" class="headerlink" title="提交任务submit"></a>提交任务submit</h2><p>提交任务和AbstractExecutorService类似，只不过提交的是返回结果排队的QueueingFuture.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="从阻塞队列获取任务结果take，poll"><a href="#从阻塞队列获取任务结果take，poll" class="headerlink" title="从阻塞队列获取任务结果take，poll"></a>从阻塞队列获取任务结果take，poll</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有完成的任务会阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有完成的任务返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有超时的获取任务结果，任务超时，则被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.poll(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java并发框架</category>
      </categories>
      <tags>
        <tag>java.util.concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS(AbstractQueuedSynchronizer) API分析</title>
    <url>/2020/11/08/AQS-api-explain/</url>
    <content><![CDATA[<h1 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h1><p>AbstractQueuedSynchronizer是Java用于替代 <strong>Synchronized+内置等待通知(wait/notify)+内置条件队列</strong>的抽象队列同步器，该同步器管理锁，条件变量(状态变量)，条件谓词三元关系，从而技术上实现了锁，条件队列，等待通知，阻塞等同步语义。在JUC中广泛使用，其中有ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch，ThreadPoolExecutor#Worker，而这些基石又组成了部分并发集合，可见其重要性，该同步器比内置的伸缩性和容错性更好，并且功能比内置的更加强大，文章主要分析AQS API设计，以及如何使用该类实现自定义的锁和同步器。</p>
<h1 id="AQS-API一览"><a href="#AQS-API一览" class="headerlink" title="AQS API一览"></a>AQS API一览</h1><p>AQS API主要分为以下几类，1 public final 方法 ，用于实现类调用以完成获取锁/释放锁的操作，2  protected final方法，用于实现类获取，原子修改状态变量， 3  protected方法，用于实现类覆写，并且协同 protected final从而真正完成等待/通知的同步语义， 4 私有方法，作为内部实现，并非API，故不分析私有方法。</p>
<h2 id="public-final-方法"><a href="#public-final-方法" class="headerlink" title="public final 方法"></a>public final 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程以独占方式用于获取锁，如果获取到，tryAcquire(arg)将会实现状态修改，否则线程将会入队，被阻塞。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程以响应中断的方式获取锁。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小于<span class="number">0</span>，共享获取失败，则线程入队阻塞。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以可响应中断的方式共享获取。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以独占方式释放，释放成功将unparkSuccessor.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以共享方式释放。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(ConditionObject condition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(ConditionObject condition)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasContended</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br></pre></td></tr></table></figure>



<p>基本获取/释放方法包含了以<strong>tryXXX</strong>开头的方法，这些方法都需要实现类自己来定义，通过对tryXXX方法覆写，从而实现自定义的获取释放操作。</p>
<h2 id="protect方法"><a href="#protect方法" class="headerlink" title="protect方法"></a>protect方法</h2><p>tryAcquire, tryRelease,isHeldExclusively是实现<strong>独占语义</strong>需要覆写的方法，而tryAcquireShared，tryReleaseShared是实现<strong>共享语义</strong>需要覆写的方法，其内部实现均为throw new UnsupportedOperationException()；简单而言，就是通过状态变量的修改来决定获取锁成功，获取锁失败被阻塞，释放锁失败，释放锁成功唤醒被阻塞线程的简单语义。本质是Synchronized+wait+notify+条件队列语义的高级实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span>     <span class="keyword">true</span>,成功获取，<span class="keyword">false</span>，失败获取，线程将入队阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span>     <span class="keyword">true</span>，成功释放，唤醒被阻塞的线程，<span class="keyword">false</span>，释放失败。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span>     <span class="keyword">true</span>，被当前线程持有，<span class="keyword">false</span>，非当前线程持有。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span>   负值，获取失败，线程入队被阻塞，零值，以独占方式获取，正值，以共享方式获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">true</span>，使得所有在获取时候阻塞的线程恢复执行，<span class="keyword">false</span> 释放失败</span></span><br></pre></td></tr></table></figure>



<p>当理解了protect的语义后，就需要在protect中调用protect final来真正操作状态变量了。</p>
<h2 id="protect-final-方法"><a href="#protect-final-方法" class="headerlink" title="protect final  方法"></a>protect final  方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span>    获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span>  设置状态  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span>  原子更新状态</span></span><br></pre></td></tr></table></figure>





<h1 id="AQS使用实战"><a href="#AQS使用实战" class="headerlink" title="AQS使用实战"></a>AQS使用实战</h1><p>当我们实现一个锁或者同步器时候，最重要的思考是你的状态变量是什么？条件谓词是什么？状态变量和条件谓词之间的转换关系？首先应该清晰理解你需要被AQS管理的状态，其次是这些状态之间转换。可以说，状态变量及其转换带来的同步语义是最重要的设计思考。我们先从官方API实例Mutex 和BooleanLatch说起，然后深入JDK例子CountDownLatch，ReentrantLock，Semaphore，最后总结实现AQS的模板。</p>
<h2 id="Mutex锁实现"><a href="#Mutex锁实现" class="headerlink" title="Mutex锁实现"></a>Mutex锁实现</h2><p>互斥锁是最经典的锁，同一时刻只能有一个线程获取锁，并且不可重入。我们可以以0为释放，1为获取作为状态，当获取锁时候，将状态从0置为1，新的线程再次获取时候，将被阻塞。当释放锁时候，将状态从1置为0，并且唤醒之前被阻塞的线程。</p>
<p>1 状态是什么？ 是否获取锁</p>
<p>2  状态转换？ 获取锁时候，状态从0修改为1，释放锁时候，状态从1修改为0.</p>
<p>3  实现细节？ 实现Lock接口，内部静态final类实现Sync，用于实现AQS的protected方法 ，公共方法调用AQS的public final方法。</p>
<p>我们来看实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 内部助手类，桥接模式</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reports whether in locked state</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//状态为1，认为是当前线程独占</span></span><br><span class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">//获取锁时候将状态从0原子更新到1，并且设置当前获取者是自己，获取成功返回true</span></span><br><span class="line">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="comment">//释放锁时候状态不能为0</span></span><br><span class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//状态更新为0</span></span><br><span class="line">       setState(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     <span class="comment">// Provides a Condition</span></span><br><span class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Deserializes properly</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">   <span class="comment">//实现lock接口，并且公共方法调用AQS的public final方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="BooleanLatch-同步器实现"><a href="#BooleanLatch-同步器实现" class="headerlink" title="BooleanLatch 同步器实现"></a>BooleanLatch 同步器实现</h2><p>布尔Latch，可以来回切换，只允许一个信号被唤醒，但是是共享获取的，所以使用tryAcquireShared，tryReleaseShared.</p>
<p>1  状态是什么？获取成功或者失败</p>
<p>2  状态转换？    成功1，失败-1</p>
<p>3  实现细节？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLatch</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1  共享获取成功   -1 共享获取失败，线程阻塞</span></span><br><span class="line">       <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//释放锁时候，将状态设置为1，并且唤醒被阻塞的线程</span></span><br><span class="line">       setState(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isSignalled(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span>         </span>&#123; sync.releaseShared(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="CountDownLatch同步器实现"><a href="#CountDownLatch同步器实现" class="headerlink" title="CountDownLatch同步器实现"></a>CountDownLatch同步器实现</h2><p>1  状态是什么？ 当前计数值</p>
<p>2  状态转换？每次减少一个计数值，直到0，才进行唤醒，当计数器大于0的时候，一直等待计数器降为0</p>
<p>3  实现细节？共享获取，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数初始化内部同步器的计数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sync的实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="comment">//初始化状态设置计数值为count</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享获取，状态为0的时候，获取成功，不为0的时候，获取失败，被阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//每次countDown时候，在for循环中不断减少初始化计数值，当减少到0的时候，释放成功，将会唤醒等待线程，当已经成为0的时候</span></span><br><span class="line">    <span class="comment">//将一直释放失败，所以CountDownLatch只能用一次。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">//降低到0的那一次，返回true，唤醒await的线程</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共API实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在EffectiveJava3的item17中有句话点评到：构造器应该创建完全初始化的对象，并且建立起所有约束关系。CountDownLatch是可变的，但是它的状态被刻意设计的非常小，比如创建一个实例，只能用一次，一旦定时器的计数达到0，就不能再用了。</p>
<h2 id="ReentrantLock锁实现"><a href="#ReentrantLock锁实现" class="headerlink" title="ReentrantLock锁实现"></a>ReentrantLock锁实现</h2><p>1  状态是什么？获取锁操作次数</p>
<p>2  状态转换是什么？同一个线程多次获取锁，累加锁操作次数，对应的多次释放锁，减少锁操作次数</p>
<p>3  实现细节？实现Lock接口，独占锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象同步器，设计为静态类，作为公平同步器和非公平同步器的父类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平同步器，静态final类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//第一次获取，判断如果没有后继者，将锁操作次数修改为acquires，并且设置自己是锁的拥有者，</span></span><br><span class="line">            <span class="comment">//setExclusiveOwnerThread是中的AbstractOwnableSynchronizer方法</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次获取，如果还是自己，则将锁获取次数累加，并且修改状态为锁的获取次数，这里也是可重入的实现，当超过</span></span><br><span class="line">        <span class="comment">//锁最大可获取次数，则抛出Error，注意Error是非受检异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平同步器，静态final类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有API</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认非公平</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.lock();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;sync.acquireInterruptibly(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.newCondition();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryLock时候，无论公平锁还是非公平锁，都是非公平获取</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//减少一次锁获取次数</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由此我们可以看到，可重入锁的最大次数是int最大值，也就是2147483647 ，同一个线程最大可以递归获取锁21亿次。</p>
<h2 id="Semaphore同步器实现"><a href="#Semaphore同步器实现" class="headerlink" title="Semaphore同步器实现"></a>Semaphore同步器实现</h2><p>1  状态是什么？当前可用许可数量</p>
<p>2  状态切换？ 每当有一个线程获取到许可时候，就将许可减1，当许可减低为0的时候，阻塞线程，直到许可大于0</p>
<p>3 实现细节？可共享获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//可用许可</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">//剩余许可</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">//剩余许可小于0或者将可用修改为剩余</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//是否有前继者，如果线程有前继者，说明已有线程被阻塞，直接返回获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">//剩余小于0或者可用修改为剩余，如果大于0，则获取成功，如果等于0，则独占获取，如果小于0，则获取失败</span></span><br><span class="line">            <span class="comment">//所有当剩余许可小于0的时候，也就是信号量使用完的时候，线程获取锁将被阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共API</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; sync = <span class="keyword">new</span> NonfairSync(permits);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     sync.acquireSharedInterruptibly(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看到，Semaphore是初始化N个许可，线程无需等待，然后每一个线程会消耗信号量，当消耗完时，会阻塞后面线程，而CountDownLatch是初始化N个计数器，然后线程等待，当计数器降为0的时候，唤醒初始化等待的线程，这两者有些相反的含义在里面。两种同用共享获取方式，共享释放释放。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4  总结"></a>4  总结</h1><p>在实现锁或者同步器时候，需要思考以下几点：</p>
<p>1  状态变量以及状态变量的转换</p>
<p>2   是独占的还是共享的</p>
<p>当想明白以上两个问题时候，就可以动手实现你要的同步器的，一般是以内部静态类的方式继承AQS的protected方法，在protected方法中，调用protected final方法，然后在你要公共API中调用你的内部同步器的public final方法既可。如下实现模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MyLock implements Lock,  or MySync &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//内部同步器，继承AQS的protected方法，里面调用AQS的protected final方法修改状态</span></span><br><span class="line">   innerStaticSync extends AbstractQueuedSynchronizer&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//独占获取 tryAcquire，tryRelease，isHeldExclusively</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">           getState/setState/compareAndSetState</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="comment">//共享获取 tryAcquireShared，tryReleaseShared</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//构造函数实例化</span></span><br><span class="line">    <span class="keyword">public</span> MyLock or MySync &#123;</span><br><span class="line">        innerStaticSync = <span class="keyword">new</span> MyLock() <span class="function">or new <span class="title">MySync</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public api 调用AQS的public final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">acquire</span><span class="params">()</span></span>&#123;innerStaticSync.acquire();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">release</span><span class="params">()</span></span>&#123;innerStaticSync.release();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Done！</p>
]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java并发框架</category>
      </categories>
      <tags>
        <tag>java.util.concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>FutureTask设计与实现</title>
    <url>/2020/11/11/FutureTask-Design-And-Implementation/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>FutureTask是Future和Runnable的实现，ThreadPoolExecutor在执行任务的时候，执行的是FutureTask. 传统Runnable接口实现的任务只有执行方法run，并没有任务取消，执行超时等功能，并且Runnable并没有提供任务状态的抽象，其实每个任务都是有状态的。所以FutureTask其内部将任务执行过程分为一系列状态，从而使得任务有了生命周期。在JDK中，经典的实现除了FutureTask外，还有ScheduledFutureTask. </p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/images/FutureTask.png" alt=""></p>
<p>我们可以看到它对一个普通任务支持了生命周期的方法. 从而使得任务执行有了过程的概念，而不是Runnable这样只能运行或者被中断的状态，也使得客户端更加灵活的控制任务执行。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>FutureTask的API全部来自父接口，自己只定义了构造函数，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务执行方法，继承自RunnableFuture的run,RunnableFuture又继承在Runnable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//run之后，获取run的结果，可能任务执行被中断，或者执行异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//带超时的获取run结果，可能抛出超时异常    </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//取消任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//任务是否被取消   </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//任务是否完成</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//钩子方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Callable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Runnable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="等待节点WaitNode"><a href="#等待节点WaitNode" class="headerlink" title="等待节点WaitNode"></a>等待节点WaitNode</h2><p>等待节点是当有多个线程获取结果的时候，会进行排队，当有一个线程get到结果时候，其他线程将被唤醒，也将拿到结果。该等待节点的实现是Treiber Stack，Treiber 是发明者名字,它是非阻塞的同步栈，详情可参考Wikipedia.  <a href="https://en.wikipedia.org/wiki/Treiber_stack" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Treiber_stack</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的实现是静态final类，意味着这是一个全局的类，和外部实例没有关系，并且不能被继承，</p>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 运行的任务 */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** get返回的结果 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"><span class="comment">/** 运行Callable的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">/** Treiber stack上的等待线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>





<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  <span class="comment">//任务状态，每个API都会和状态相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>任务的状态有7种，每种任务状态是递增且不可逆的。下面是状态流转图：</p>
<img src="/images/FutureTaskStatus.png" style="zoom:50%;" />

<p>任务起始状态是NEW，中间过程有COMPLETING和INTERRUPTING，终态有四种，也就是图的叶子节点。这些状态使得任务可以被控制。</p>
<h2 id="任务运行run"><a href="#任务运行run" class="headerlink" title="任务运行run"></a>任务运行run</h2><p>任务运行是实现run方法，也就是客户端自定义的任务。</p>
<p>run方法首先判断状态，如果任务状态不NEW，则直接退出，防止任务重复执行，然后进入真正任务执行，调用Callable的call方法，</p>
<p>call结束，任务执行完成，将ran置为ture，正常情况调用set，如果运行中发生异常，调用setException，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断状态是不是NEW</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正任务执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                <span class="comment">//执行完成设置ran为true</span></span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">//任务执行发生异常</span></span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//修改任务执行状态为异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">//修改任务执行状态为正常结束</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果发生异常将任务状态设置为EXCEPTIONAL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果正常执行完成，将任务状态设置为NORMAL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取任务结果get"><a href="#获取任务结果get" class="headerlink" title="获取任务结果get()"></a>获取任务结果get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从API可以看出，获取任务结果时候，任务可能被中断，或者发生执行异常。</p>
<h3 id="awaitDone-自旋等待结果"><a href="#awaitDone-自旋等待结果" class="headerlink" title="awaitDone 自旋等待结果"></a>awaitDone 自旋等待结果</h3><p>读这段代码时候，一定要想着会有多个线程来awaitDone，并且每一个线程都在自旋，等待状态变化。每个线程按照排队方式排列在waiters进行等待。</p>
<p>假设有四个线程同时获取结果，每一个运行1s后，才启动另一个线程，那么每个线程第一次进入awaitDone时候将会创建自己的WaitNode，然后第二次进入会发现queued=false，然后将第一次进入的创建WaitNode节点next指向waiters，如Thread1 -&gt; waiters,</p>
<p>第三次进入时候，因为所有的分支条件只满足最后一个，调用LockSupport.park(this)，此时该线程因为一直没有获取结果而进行wait，此时线程状态变成waiting。依次类推，第二个线程进入，第三个线程进入，第四个线程进入，将会形成以下结构：</p>
<img src="/images/FutureTaskStack.png" style="zoom:80%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timed false说明没有超时时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//当任务执行时候，一直在自旋等待状态变化，为了不断获取任务执行过程中的状态。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//大于COMPLETING的其他状态，直接返回状态,该状态主要改变会在run方法中改变</span></span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//线程被中断时候，移除等待节点上的线程，并且告诉客户端发生了中断，</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次进入时候，WaitNode为空，创建新的等待节点。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//如果</span></span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="comment">//如果有超时实现限制，则会不断和最终时间进行比较，超过最终时间，状态返回NEW，并且在外层抛出</span></span><br><span class="line">            <span class="comment">//TimeoutException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                <span class="comment">//park当前线程</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//所有排队的线程均会被park住.</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finishCompletion-完成任务"><a href="#finishCompletion-完成任务" class="headerlink" title="finishCompletion 完成任务"></a>finishCompletion 完成任务</h3><p>当有任务完成时候，会将Tribie Stack等待的线程全部unpark，并且释放每个WaitNode的线程.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="带超时的get"><a href="#带超时的get" class="headerlink" title="带超时的get()"></a>带超时的get()</h2><p>这块和get()其实差不多，只是会进入get的不同for(;;)分支，当超过指定时间没有返回结果时候，将会抛出TimeoutException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="取消任务cancel"><a href="#取消任务cancel" class="headerlink" title="取消任务cancel"></a>取消任务cancel</h2><p>任务取消成功返回true，取消失败返回false，可以从条件判断中得知，当状态为NEW，且被原子更新为INTERRUPTING或CANCELLED，</p>
<p>才能取消任务。当可以中断时候，任务通过中断实现的，中断之后将任务状态设置为INTERRUPTING，当不可以中断，任务取消其实并没有做什么，只是将任务状态修改为或CANCELLED，当任务状态发生变化时候，一直自旋等待线程会在get方法中获得状态变化，从而执行相关分析，最后执行finishCompletion.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="是否取消isCancelled"><a href="#是否取消isCancelled" class="headerlink" title="是否取消isCancelled"></a>是否取消isCancelled</h2><p>根据状态判断，因为状态是递增的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="是否完成isDone"><a href="#是否完成isDone" class="headerlink" title="是否完成isDone"></a>是否完成isDone</h2><p>同样根据状态判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state != NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h1>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java并发框架</category>
      </categories>
      <tags>
        <tag>java.util.concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架(3)-HashMap设计与实现</title>
    <url>/2020/11/14/HashMap-Design-And-Implementation/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>​          HashMap在面试中被频繁问到，从我入行(2015年)问到了现在，我一直思考，就一个Map的实现有什么好问的，曾经对问我HashMap的面试官忍不住吐槽：难道你们没别的问的了？但是不可避免这个问题的出现频率，因为这体现你的“Java基础”。于是为了回答好这个问题，我从网上看了很多资料，从此面试时候不在被HashMap所难倒，但是我好像除了应付面试，从HashMap并没有学到什么东西，有一天，我下定决心，真正地重新学习HashMap的实现，从此好像发现了宝藏一样，对我的代码水平提高也很有帮助，从最初的迷惑，不屑，到现在对HashMap的喜欢，也是见证自己对技术从实用主义到真正渴望理解的一个提高，也是从浮躁到沉淀的一个见证。所以这篇文章总结了自己对HashMap的设计与实现的认识。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​          HashMap作为最经典的Map接口实现，内部实现细节非常复杂，但是设计本身实现却是一致的，没有脱离Map接口和整个集合框架带给我们的抽象。<strong>Node</strong>和<strong>TreeNode</strong>作为<strong>Map.Entry</strong>的实现类，代表了<strong>HashMap</strong>内部的不同类型<strong>Entry</strong>， <strong>KeySet，Values，EntrySet</strong>分别作为Map的key,value，Entry的视图. 而<strong>HashIterator，KeyInterator，ValueIterator，EntryIterator</strong>分别作为KeySet，Values，EntrySet的迭代器实现，用于遍历Map，而<strong>HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator</strong>作为HashMap支持流式编程的Spliterator的实现。虽然看着类很多，但是抽象围绕<strong>迭代器，分割器，视图，Entry</strong>去实现的。由此可以得知，支持HashMap的实现由这些基本抽象组成。在接下来结构中，可以体现这些细节。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>HashMap的内部结构较多，但是并不难以理解。</p>
<p><img src="/images/HashMap.png" alt=""></p>
<h1 id="HashMap的API"><a href="#HashMap的API" class="headerlink" title="HashMap的API"></a>HashMap的API</h1><h1 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h1><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>java.util.*</tag>
        <tag>java collection framework</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.OutOfMemoryError内存溢出</title>
    <url>/2020/08/16/OOM/</url>
    <content><![CDATA[<p>对这个问题的深入理解，取决于对GC，内存本身的理解。终极问题。</p>
<p>内存，GC，</p>
<p>内存溢出指的是程序需要内存超出系统所有的内存，如果是正常情况调大jvm内存即可，如果是</p>
<p>Java内存区域分为这么几个区域</p>
<p>堆区：老年代，新生代</p>
<p>非堆：metaspace</p>
<p>FullGC之后空间不足，内存没有回收。</p>
<p>Java OOM情况有以下几种，</p>
<h3 id="java-heap-space"><a href="#java-heap-space" class="headerlink" title="java heap space"></a>java heap space</h3><p>原因：1 应用需要更多对空间  2    内存泄漏（类加载器内存泄露，ThreadLocal 不remove内存泄漏，和线程池一起使用会泄漏）</p>
<p>举例：</p>
<p>解决方案：</p>
<p>这种情况属于fullgc之后，堆空间不足，内存泄漏是内存溢出的一个原因，但是内存泄漏不一定导致内存溢出。</p>
<h3 id="GC-Overhead-limit-exceeded"><a href="#GC-Overhead-limit-exceeded" class="headerlink" title="GC Overhead limit exceeded"></a>GC Overhead limit exceeded</h3><p>频繁FullGC导致该错误</p>
<h3 id="Permgen-space"><a href="#Permgen-space" class="headerlink" title="Permgen space"></a>Permgen space</h3><p>Java7 持久代空间不足</p>
<h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><p>Java8</p>
<p>1 应用加载类太多了</p>
<p>2 classloader内存泄漏</p>
<p>元空间不足，java8之后才会有</p>
<h3 id="Unable-to-create-new-native-thread"><a href="#Unable-to-create-new-native-thread" class="headerlink" title="Unable to create new native thread"></a>Unable to create new native thread</h3><p>本地线程创建数量超过操作系统的线程数</p>
<h3 id="Out-of-swap-space？"><a href="#Out-of-swap-space？" class="headerlink" title="Out of swap space？"></a>Out of swap space？</h3><p>交换区</p>
<h3 id="Compressed-class-space"><a href="#Compressed-class-space" class="headerlink" title="Compressed class space"></a>Compressed class space</h3><h3 id="Requested-array-size-exceeds-VM-limit"><a href="#Requested-array-size-exceeds-VM-limit" class="headerlink" title="Requested array size exceeds VM limit"></a>Requested array size exceeds VM limit</h3><h3 id="reason-stack-trace-with-native-method"><a href="#reason-stack-trace-with-native-method" class="headerlink" title="reason stack_trace_with_native_method"></a>reason stack_trace_with_native_method</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Oracle官网 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE" target="_blank" rel="noopener">Understand the OutOfMemoryError Exception</a></li>
<li>Plumbr The 8 symptoms that surface <a href="https://plumbr.io/outofmemoryerror" target="_blank" rel="noopener">outofmemoryerror</a></li>
<li>Wikipedia <a href="https://en.wikipedia.org/wiki/Out_of_memory" target="_blank" rel="noopener">Out of memory</a></li>
<li>Ponnam Parhar的slide  <a href="https://www.slideshare.net/PoonamBajaj5/get-rid-of-outofmemoryerror-messages" target="_blank" rel="noopener">Slides</a>  <a href="https://www.youtube.com/watch?v=iixQAYnBnJw" target="_blank" rel="noopener">Video</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>内存溢出</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal设计,实现,使用注意</title>
    <url>/2020/11/15/ThreadLocal-Design-And-Implementation/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程局部变量是避免多线程读取共享变量造成竞争的一种机制，每个线程只能看到自己的私有变量，这就避免了锁竞争问题。在Java中，使用ThreadLocal可以实现该机制。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>在Java的ThreadLocal中，一个线程拥有多个ThreadLocal，每个ThreadLocal的变量存储在包级可见的内部静态类ThreadLocalMap中，ThreadLocalMap的Key是用WeakReference包装的ThreadLocal，Value则是强引用普通变量，每个ThreadLocal及其变量以KV形式存储在ThreadLocalMap中，而ThreadLocalMap并没有实现Map接口，而是自己实现了类似Map的功能。当前线程不在活跃的时候，垃圾收集器回自动回收ThreadLocal。即使内部细节非常多，但是ThreadLocal暴露给客户端的API确是非常简单，核心方法仅有initialValue，set，get，remove方法，这是经过多次改进后的设计。下图是结构图：</p>
<p>单一线程：</p>
<img src="/images/ThreadLocalMap.png" style="zoom:75%;" />



<p>多线程：</p>
<p><img src="/images/ThreadLocalMultiThread.png" alt=""></p>
<p>从图中得出结论：</p>
<p>多个线程使用同一个ThreadLocal时候，每个线程会在内部创建一个自己的ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=多:一:多</p>
<p>一个线程使用多个ThreadLocal时候，一个线程创建了多个 ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=一:多:一</p>
<p>所以ThreadLocalMap数量和线程数有关。ThreadLocal是和一个领域或者业务有关。</p>
<p>下图是类图：</p>
<p><img src="/images/ThreadLocal.png" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h1 id="API演进"><a href="#API演进" class="headerlink" title="API演进"></a>API演进</h1><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h1><p>1 由于每个线程的可以有多个ThreadLocal，每个ThreadLocal是唯一的，所以定义ThreadLocal时候需要定义成static final，并且初始化一个值。</p>
<p>2 当已经给ThreadLocal设置值后，最好不需要时候主动remove，防止线程变量泄漏。</p>
<p>3  当有父子线程需要共享传递值的时候，需要使用ThreadLocal的子类InheritableThreadLocal.</p>
<p>4 当使用线程池更需要注意由于线程的可复用性，所以可能导致复用的线程拥有之前任务所传递的ThreadLocal局部变量，所以要在任务结束之后finallyremove该Worker的局部变量。</p>
<p>5 内存泄漏和变量泄漏问题。</p>
]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>java.lang</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架(1)-接口定义类型</title>
    <url>/2020/11/09/JCF-HighLevel/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>集合框架是任何语言的技术体现，是语言的综合使用的类库，大部分工作可以用集合完成，但是单独的看每一个集合实现类难以对集合框架产生一个宏观认识，所以需要从高层角度来看集合技术，本系列将分析集合框架的设计与实现。</p>
<p>集合设计包括<strong>接口，实现和算法</strong>三大核心功能。接口包括类型接口和迭代器接口，类型接口是List，Set，Map，Queue等接口，而迭代器接口包括顺序迭代器和分割器，实现包括骨架实现，视图实现，数据结构实现，骨架实现就是AbstractList，AbstractSet，AbstractMap,AbstractQueue等实现，视图实现比如ArrayList的SubList，HashMap的KeySet，Values和EntrySet，而数据结构实现是特定的类型实现比如List有ArrayList和LinkedList，算法主要有排序，查找，shuffle 等，这三个功能构成了集合的设计核心。</p>
<p>使用集合类型有非常多的好处：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>集合中最重要的是接口，接口定义了数据类型，抽象类实现了接口，而具体集合类实现了真正的类型。接下来会分析每种数据结构类型接口方法，根本特征以及不同类型之间的真正区别。</p>
<h3 id="基本接口"><a href="#基本接口" class="headerlink" title="基本接口"></a>基本接口</h3><img src="/images/JCF-Base.png" style="zoom:67%;" />

<p>集合的基本组成是元素，元素即对象。这些元素本身是普通对象，但是被集合框架管理起来就具有鲜明特点，如可以迭代，可以被分割，可以比较大小排序，而正是这些基础的能力构成了集合最核心的三大接口：<strong>Iterator，Spliterator，Comparator</strong>.</p>
<p><strong>Iterator</strong>提供了种不需要知道集合实现就能遍历的能力,也是经典的设计模式。</p>
<p><strong>Spliterator</strong>提供了分割集合的能力，在并行遍历中常用。</p>
<p><strong>Comparator</strong>提供了元素比较大小的能力，在排序中常用。</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection是JCF的顶级接口，该接口定义了集合的基本操作，其中分为查询，修改，块操作，基本对象操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">Object[] toArray();</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"><span class="comment">//修改，在List/Set/Queue中也会重新定义这些方法，因为这些方法在这些接口中有了新的含义，异常也和Collection</span></span><br><span class="line"><span class="comment">//add接口异常也不一样，因为add对于不同接口意思不同，，如List.add只是添加元素，Set.add添加不同元素，Queue.add</span></span><br><span class="line"><span class="comment">//如果超过了Queue长度，会抛出异常。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//块操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//基本对象操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些操作定义了Collection基本操作，也是契约。而这些子接口Set，List，Queue有些重新定义了Collection接口方法，有些则没有，因为不同接口的含义不同。比如List，Set，Queue都重新定义了add方法，但是List，Set定义size()方法，Queue却没有定义，因为我认为size方法在List和Set(cardinality)含义不同，但是Queue的size含义和Collection一样。这种<strong>父接口定义方法，在子接口重新定义方法</strong>的技巧在JCF中广泛使用。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><img src="/images/List-Impl.png" style="zoom:67%;" />



<p>List是一种Collection，但是Collection不一样，List支持index访问，所以List接口新加了关于index的方法，index是List最重要的抽象之一.同时List也把Collection中的方法重新定义了下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><img src="/images/set-impl.jpg" style="zoom:67%;" />

<p>Set接口将Collection方法几乎全部定义了遍，因为Set具有数学意义上集合的含义，所以集合操作需要新定义一套契约，用来表达Set的不同于Collection之处。</p>
<h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><p><img src="/images/Queue-Impl.png" alt=""></p>
<p>Queue也是一种Collection，但是接口中并没有新加任何方法，只是把Collection接口方法重新定义了下，因为和Collection内涵不一样。但是仅仅重新定义了add方法，其他方法并没有重新定义，因为add方法在Queue满的时候会抛出异常。这和List，Set，Collection均不一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队，如果队列满抛出IllegalStateException异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//入队，如果队列满返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//出队队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//出队队头元素，没有元素则返回false</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查看队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查看队头元素，没有元素则返回false</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>队列方法比较对称，add/remove，offer/poll，element/peek，这也是API对称设计的范例。</p>
<h3 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h3><p><img src="/images/Deque-Impl.png" alt=""></p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><img src="/images/Map-Impl.png" style="zoom:67%;" />



<p>Map接口里面的Map.Entry</p>
<p>map接口</p>
<p>以上便是集合框架最重要的接口和实现(不包括并发集合，并发集合将在并发中分析)了，我们接下来分析将会围绕抽象实现和具体集合类而展开</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/tutorial/collections/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/</a></p>
]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>java.util.*</tag>
        <tag>java collection framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架(2)-抽象实现骨架</title>
    <url>/2020/11/09/JCF-AbstractInterfaceImpl/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>接口定义类型，抽象类实现骨架</strong>。抽象类不支持的实现方法便是细节。这种技巧在JCF中是标配。一来替客户端提供如何实现一个接口的最直接的参考。二来帮助客户端以此实现功能更强的接口。如Guava的集合也是参考这种模式。</p>
<h1 id="抽象实现"><a href="#抽象实现" class="headerlink" title="抽象实现"></a>抽象实现</h1><p>抽象类的最重要分析是留下了哪些抽象方法，而留下的抽象方法是真正实现类的差异，而抽象类中的普通方法使用抽象方法来实现，而抽象方法实现由实现类实现，并且抽象类没有任何字段，所以也能从侧面体现留下的抽象方法的价值。可以认为抽象实现是模板模式的一种应用。</p>
<h2 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是AbstractCollection最核心的两个抽象方法，其余方法实现均是调用这两者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非常简单，size()=0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过遍历迭代器来查找元素，元素为空，找出Collection中第一个为空的元素，元素不为空，</span></span><br><span class="line"><span class="comment">//找出第一个在集合中的元素，对象需要实现equals方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))  <span class="comment">//对象equals方法很重要</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出异常，因为子类可以实现可变或者不可变集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过迭代器删除，equals方法很重要</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="containsAll"><a href="#containsAll" class="headerlink" title="containsAll"></a>containsAll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//modified来判断集合是否改变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过迭代器删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历迭代器，删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看到抽象方法在实现普通方法时候是基本每个方法都会调用。</p>
<h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractList抽象方法有两个，1是新定义的get 2是继承父类的size，而父类AbstractCollection中的抽象方法只实现了一个iterator()，因为对于List来说，iterator行为是确认的。但是get行为需要子类实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在AbstractList实现中，定义了Itr, ListItr两个迭代器，以及用于实现内部视图的SubList和RandomAccessSubList.</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Itr"><a href="#Itr" class="headerlink" title="Itr"></a>Itr</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 游标位置，指向当前元素**/</span></span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**调用next后之前的元素，-1说明刚被删除了*/</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *期望修复次数是不是等于实际修改次数，用户判断遍历时候是否被修改，如果不同则会抛出ConcurrentModificationException</span></span><br><span class="line"><span class="comment">     * 因为这些集合不是在线程安全的，所以并发修改会报错。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();<span class="comment">//检查是否被修改</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor; <span class="comment">//当前位置的cursor存储起来</span></span><br><span class="line">            E next = get(i);<span class="comment">//抽象方法get获取元素</span></span><br><span class="line">            lastRet = i;<span class="comment">//更新上一个元素位置</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;<span class="comment">//cursor下移一位</span></span><br><span class="line">            <span class="keyword">return</span> next;<span class="comment">//返回当前元素</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//调用删除方法</span></span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor) <span class="comment">//</span></span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;<span class="comment">//lastRet设置为-1</span></span><br><span class="line">            expectedModCount = modCount;<span class="comment">//修改次数等于期望修改次数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListItr"><a href="#ListItr" class="headerlink" title="ListItr"></a>ListItr</h3><p>ListItr实现了ListIterator接口，ListIterator和Iterator不同之处在于Iterator只支持向后遍历，但是ListIterator同时支持向后和向前遍历。也支持任意位置开始的遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;<span class="comment">//前一个元素索引</span></span><br><span class="line">            E previous = get(i);<span class="comment">//获取前一个元素</span></span><br><span class="line">            lastRet = cursor = i;<span class="comment">//设置lastRet = cursor等于前一个元素索引</span></span><br><span class="line">            <span class="keyword">return</span> previous;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SubList"><a href="#SubList" class="headerlink" title="SubList"></a>SubList</h3><h3 id="RandomAccessSubList"><a href="#RandomAccessSubList" class="headerlink" title="RandomAccessSubList"></a>RandomAccessSubList</h3><h2 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h2><p>AbstractSequentialList新加创建List迭代器的抽象方法listIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h2><p>AbstractSet没有新加任何抽象方法，由于继承了AbstractCollection，所以它的实现是基于iterator和size的。</p>
<h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><p>AbstractMap中的抽象方法只有entrySet，可以推断其他方法均是基于该方法实现的。因为键值对的唯一性，所以使用Set存储每一个Entry，虽然Entry好像是数据类，但是本质是有行为的类。每一个Entry代表了一个键值对，我们只能修改value，获取kv，但是不能修改key，这是Entry接口带来的契约，也是设计Entry的点，如果key可以被更新，那么这个map行为将变得不可预期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们注意到Entry对KV的抽象，</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AbstractMap中提供了两个Map.Entry的实现，一个可变的SimpleEntry，一个不可变的SimpleImmutableEntry.SimpleEntry的实现非常简单，没有任何难以理解的地方，我们来看下：</p>
<h3 id="SimpleEntry"><a href="#SimpleEntry" class="headerlink" title="SimpleEntry"></a>SimpleEntry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>) <span class="comment">// Conditionally serializable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>) <span class="comment">// Conditionally serializable</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key   = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key   = entry.getKey();</span><br><span class="line">        <span class="keyword">this</span>.value = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key   == <span class="keyword">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">               (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SimpleImmutableEntry"><a href="#SimpleImmutableEntry" class="headerlink" title="SimpleImmutableEntry"></a>SimpleImmutableEntry</h3><p>和SimpleEntry不同的地方在于setValue方法抛出UnsupportedOperationException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查询方法实现"><a href="#查询方法实现" class="headerlink" title="查询方法实现"></a>查询方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> entrySet().size();<span class="comment">//调用抽象方法实现，set().size()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取出Set的迭代器进行key的查找，</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getValue()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的get方法实现复杂度是O(N),因为需要遍历整个Entry Set迭代器，这只是</span></span><br><span class="line"><span class="comment">//一种实现方法，如果客户端有更加高效的实现方式，则可以覆写该方法，如HashMap</span></span><br><span class="line"><span class="comment">//的高品质实现，同时因为Map只是定义了接口，并不是实现，Abstract只是定义了</span></span><br><span class="line"><span class="comment">//一种简单的实现，帮助客户端减少实现难度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="修改操作方法"><a href="#修改操作方法" class="headerlink" title="修改操作方法"></a>修改操作方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//put方法在这里没有实现，也没有办法实现，正如add方法在AbstractCollection/List/Set中无法实现一样</span></span><br><span class="line"><span class="comment">//因为你不知道放入的数据结构，真正的数据结构定义是在实现类中，如HashMap，TreeMap这里面，</span></span><br><span class="line"><span class="comment">//正是因为抽象类的实现没有引入成员变量，所以放入时候才不会指定特定的存储细节，这也是</span></span><br><span class="line"><span class="comment">//集合框架获得灵活性的重要机制，如果在抽象类中引入了成员变量作为存储结构，那么子类的实现将会</span></span><br><span class="line"><span class="comment">//被束缚在抽象类，此时抽象类将不再抽象，而是一种实现了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//entrySet是抽象方法</span></span><br><span class="line">    entrySet().clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个key，其实遍历entrySet，找到key对应的Entry，然后调用迭代器remove方法</span></span><br><span class="line"><span class="comment">//删除该元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        Entry&lt;K,V&gt; correctEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                    correctEntry = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                    correctEntry = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V oldValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (correctEntry !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            oldValue = correctEntry.getValue();</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="视图方法"><a href="#视图方法" class="headerlink" title="视图方法"></a>视图方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//key的视图是set，因为key不能重复，每个Map只有一个视图，每个视图通过entrySet引用了</span></span><br><span class="line"><span class="comment">//真正Map的元素，可以看出视图实现了AbstractSet.第一次调用时候，keySet视图为空，创建视图。</span></span><br><span class="line"><span class="comment">//第二次调用时候，使用第一次的视图。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//next是key</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为value可以有重复的，所以使用Collection存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vals = values;</span><br><span class="line">    <span class="keyword">if</span> (vals == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vals = <span class="keyword">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getValue();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsValue(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        values = vals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>java.util.*</tag>
        <tag>java collection framework</tag>
      </tags>
  </entry>
  <entry>
    <title>RSMA模型:软件系统模型的探索(2)</title>
    <url>/2023/07/15/application-thinking/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>在做应用系统时候，会遇到很多问题，比如接口响应慢，排查然后解决问题，具体解决有：代码优化，索引优化，慢查询告警，运维层面的监控，告警，通过排查问题，我们对系统有了更深入了解，对整个链路越来越熟悉，并在解决过程中提高了技术能力。但是有时候我们真的解决问题了吗？接口从5s优化到100ms，是否解决了接口慢的问题呢？是的，至少表面来看问题解决了，但是我们怎么能保证的说：系统没问题了。我们希望有一个完美系统，让自己系统来和”完美系统“进行比较，从而发现系统问题，从而不断优化系统。完美的理论是存在的，但是完美的系统存在脑海中，并且谁也没见过。我觉得完美系统应该是一系列目标，比如<strong>可靠性</strong>，系统在完成功能很可靠，系统在宕机，硬件故障，软件错误，人为故障时候可以可靠运行，还比如<strong>可扩展性</strong>，当遇到性能问题时候，可以横向或者纵向扩展，再比如<strong>可维护性</strong>，小到代码，中到架构，大到系统方方面面可维护性，这些都可以定义系统的目标（非业务层面）。</p>
<p>那么接口慢可以反应哪些问题呢？</p>
<ol>
<li><p>可靠性：系统对用户使用造成问题，用户可能离开，使得用户觉得系统不可靠。系统发生错误。</p>
</li>
<li><p>可扩展性：接口慢，是性能问题，性能问题垂直扩展还是水平，还是代码，存储层问题呢？</p>
</li>
<li><p>可维护性：有监控吗？有告警吗？排查问题工具是否容易使用呢？是否有全链路traceid一眼看到链路耗时呢？</p>
</li>
</ol>
<p>接口慢也侧面反映了，系统没有预期的目标。</p>
<h1 id="RSMA模型"><a href="#RSMA模型" class="headerlink" title="RSMA模型"></a>RSMA模型</h1><p>RSMA（Reliable，Scalable，Maintainable，Automate）模型是将系统属性和目标分解为三部分：可靠性，可扩展性，可维护性，到达这些目标更好的方式是：自动化。</p>
<p>可靠性包含：硬件故障，软件错误，人为失误。有些时候，系统看似可靠，实际上不是，需要明确可靠性在不同层面的真正含义。</p>
<p>可扩展性包含：负载，性能。性能问题是可扩展的核心。虽然没了资源（内存/CPU/带宽）可以加，但是为什么每次不是自动化过程呢？虽然没有见过自动扩展的系统，但是可以作为设计的目标。</p>
<p>可维护性包含：可运维，简单化，易演化。</p>
<p>自动化包含：实现上面目标最好是自动化的。其次是手动化的。</p>
<p>RSMA模型认为：系统首要是拥有目标，然后在解决问题，演化，调优中不断接近目标。解决问题完成定义是达到目标。所有问题都可以定义一个目标，而这些目标最终会成为可靠性，可扩展性，可维护性三者之一。实现三者方式应该是自动化的。</p>
<h1 id="一些观点"><a href="#一些观点" class="headerlink" title="一些观点"></a>一些观点</h1><ol>
<li>很多系统缺乏明确目标，解决问题方案偏临时，不能从整体上来拆解问题。任何问题都可以追溯一个目标。</li>
<li>一个系统的长期目标是业务方向，中期目标是系统目标，短期目标是业务需求。</li>
<li>系统会出现多种问题，定义<strong>问题解决</strong>了标志应该是：解决该问题达到了系统的目标。那么系统没问题也应该是达到了系统的目标。否则接口从5s优化到100ms，解决了很多技术问题，但是怎么定义解决呢？用户觉得快也是目标，但是快拆解目标是<strong>可扩展性</strong>。</li>
<li>系统的目标是：RSMA，应该牢记系统的目标，并且拆解可落地方案。业务系统，存储系统，中间件系统的目标均可以是上述三个。</li>
<li>系统的目标是系统层面的属性，是应用系统设计目标，影响了系统的方方面面，而非某个特定的技术，是各个组件合力贡献的能力。目标也不是个体事情，开发，运维，测试，是多人协同的实现属性。</li>
<li>COSEA是还原论，将系统拆分，而RSM是系统论，将系统组合。</li>
<li>实际和理论割裂很严重，系统没资源了，连自动加资源能力都没有，每次都要手动加，包括内存资源，产生这些问题原因在哪里？所谓的自动垂直扩展，自动水平扩展，自动弹性扩展没见过。</li>
</ol>
]]></content>
      <categories>
        <category>模型</category>
        <category>软件模型</category>
      </categories>
      <tags>
        <tag>软件系统模型</tag>
        <tag>RSM模型</tag>
        <tag>创造</tag>
      </tags>
  </entry>
  <entry>
    <title>CRUD Boy和API Caller的怪象</title>
    <url>/2021/01/01/Think-CRUDBoy-APICaller/</url>
    <content><![CDATA[<p>CRUD，API Caller，Copy Paste 在业界被认为很低级工作，和low的技能(更多是自黑)。Spring作者Rod Johnson曾用一个比喻来说明问题，多瘤程序员: 学会一门技术但是留下来很多伤疤。经常认为和带着这样想法工作会降低个人生产力和对工作技术的敏感度。</p>
<h1 id="CRUD-Boy"><a href="#CRUD-Boy" class="headerlink" title="CRUD Boy"></a>CRUD Boy</h1><p>​        CRUD指的是对存储层的增删改查和业务层的逻辑计算。毕竟业务逻辑就是存储和计算。低级之处在于程序开发仅仅是对数据库数据的事务脚本操作，但是业务系统设计，在小型项目中CRUD可以Hold住复杂度，但是当业务系统复杂起来时候，事务脚本将带来维护性和扩展性问题，此时系统的各种业务逻辑和组件将会变得非常复杂且无趣。解决这个办法在于<strong>良好的业务抽象</strong>和概念<strong>一致性的业务接口</strong>，此时CRUD将不再是事务脚本，而更类似于OOD，而随着业务演进，可能会拆分微服务，这时候如果没有从CRUD泥潭出来，新建的微服务还是会重复事务脚本的老路。而业界有更好的业务设计方法，是<strong>领域驱动设计</strong>，将业务设计和技术设计结合起来，可以借鉴其思想，有句话说的比较好DDD is OOD done right.</p>
<p>​       同时CRUD代码也不是没有技术含量的，CRUD代码也需要扩展性，维护性，可读性，文档注释，可测试性，不断重构达到整洁代码的水平，而这些任意一个工程实践，都会对既有团队带来编码习惯带来改变和编程水平的提高。所以CRUD没有技术含量，是更多把CRUD当做业务需求翻译机，产品说加你就加，而不是业务需求的解释器，用技术语言来设计业务。</p>
<p>​       </p>
<h1 id="API-Caller"><a href="#API-Caller" class="headerlink" title="API Caller"></a>API Caller</h1><p>API Caller是只会简单用类库和调第三方接口，没有完全理解调用方。这种透明性对业务开发进度有帮助，但是对于个人技术成长却是弊大于利。比较典型的例子是你用别人封装好的Redis接口查数据，会错以为自己会Redis，用厂商提供好的mq接口开发，发送几条消息，消费几条消息就认为自己用过mq，从而在实际工作中变成了只会调用API。在Java类库中，NIO代码冗余且复杂，学习NIO API本身就是对NIO的学习，但是写完就忘，下次还要重新学习，但是下次的学习或许没有从更深概念理解NIO，而是重新学了一遍NIO API使用代码，这样比较浪费时间。</p>
<p>对于高质量的程序，绝大部分是注重API设计质量的，这不仅关系到API使用，还有API的理解性上，好的API本身就会抽象最核心的概念给开发者，模块间通信也会精心设计API。在JAVA世界中，集合框架和并发包可以说是对API契约和设计的经典案例，任何学习API设计的都可以从此开始研究，光看集合提供的接口，就能够收获非常多的概念和抽象。同时高质量API的文档也能够加深对技术的理解。当然API的实现也很重要，但是重要程度不如API本身。关于这方面可以参考：<a href="https://xiaozhiliaoo.github.io/2020/11/09/JCF-HighLevel/" target="_blank" rel="noopener">集合接口</a></p>
<p>我们以Guava Cache来分析从API中能获得什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LoadingCache的父接口Cache也包含非常多的方法，这里不做探讨。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Function</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">      <span class="function">V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line">      <span class="function">V <span class="title">getUnchecked</span><span class="params">(K key)</span></span>;</span><br><span class="line">      <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">getAll</span><span class="params">(Iterable&lt;? extends K&gt; keys)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Loads a new value for key &#123;<span class="doctag">@code</span> key&#125;, possibly asynchronously. While the new value is loading</span></span><br><span class="line"><span class="comment">       * the previous value (if any) will continue to be returned by &#123;<span class="doctag">@code</span> get(key)&#125; unless it is</span></span><br><span class="line"><span class="comment">       * evicted. If the new value is loaded successfully it will replace the previous value in the</span></span><br><span class="line"><span class="comment">       * cache; if an exception is thrown while refreshing the previous value will remain, &lt;i&gt;and the</span></span><br><span class="line"><span class="comment">       * exception will be logged (using &#123;<span class="doctag">@link</span> java.util.logging.Logger&#125;) and swallowed&lt;/i&gt;.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;Caches loaded by a &#123;<span class="doctag">@link</span> CacheLoader&#125; will call &#123;<span class="doctag">@link</span> CacheLoader#reload&#125; if the cache</span></span><br><span class="line"><span class="comment">       * currently contains a value for &#123;<span class="doctag">@code</span> key&#125;, and &#123;<span class="doctag">@link</span> CacheLoader#load&#125; otherwise. Loading is</span></span><br><span class="line"><span class="comment">       * asynchronous only if &#123;<span class="doctag">@link</span> CacheLoader#reload&#125; was overridden with an asynchronous</span></span><br><span class="line"><span class="comment">       * implementation.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;Returns without doing anything if another thread is currently loading the value for &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">       * key&#125;. If the cache loader associated with this cache performs refresh asynchronously then this</span></span><br><span class="line"><span class="comment">       * method may return before refresh completes.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">(K key)</span></span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to</span></span><br><span class="line"><span class="comment">       * the map directly affect the cache.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;Iterators from the returned map are at least &lt;i&gt;weakly consistent&lt;/i&gt;: they are safe for</span></span><br><span class="line"><span class="comment">       * concurrent use, but if the cache is modified (including by eviction) after the iterator is</span></span><br><span class="line"><span class="comment">       * created, it is undefined which of the changes (if any) will be reflected in that iterator.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先看<strong>get</strong>方法，抛出了ExecutionException异常，这个异常定义在并发包java.util.concurrent下，所以可以猜测get时候会不会和并发，多线程执行有关.否则不可能无缘无故抛出这么个异常。事实证明猜测是对的，Guava对于<a href="https://github.com/google/guava/wiki/CachesExplained#interruption" target="_blank" rel="noopener">Interruption</a>的处理很多设计决策。</p>
<p><strong>getUnchecked</strong>同样是获取v方法，没有抛出任何异常，方法名是获取非受检异常，可以看出获取key的时候，一定会报错，但是提供了更加灵活的异常处理机制，而这些知识，就需要对受检异常和非受检异常有清晰的认识才能设计出这样的API，否则是不会想到这一层的。</p>
<p><strong>getAll</strong>这个接口设计很有意思，传参是Iterable，足够看到其通用和扩展性，但是返回确是不可变的Map，看到这里，是不是觉得比较有趣呢？可以质疑为什么不用List接口呢？当然使用的时候传入Key List是可以的，但是如果你不理解Iterable的接口，你这段代码很有可能需要百度demo才能写出来，下次遇到同样的问题还是没有任何进步，成为了API Caller。</p>
<p><strong>refresh</strong>从方法签名看不出什么，但是API文档注释非常详细，足够了解了。</p>
<p><strong>asMap</strong> 是缓存的视图，但是修改缓存视图会导致底层缓存被修改，并且用的是并发的Map接口，此时几乎可以得出结论，缓存大概率会并发读写的，所以benchmark时候，并发读写能力一定是一个点。此时你对ConcurrentMap操作时候就需要清晰地了解ConcurrentMap的特性，并发修改时候遍历等问题。如果你希望业务层缓存只能用来读，而缓存层做缓存更新的话，你可以将asMap包装成不可变的Map. 当转换成Map时候，疑问在于关于Cache的契约是否就会被打破了？比如get时候load数据。</p>
<p>可以看到，还没有看LoadingCache的实现，我们就可以很多，看完核心接口，在辅以文档，可以说对Cache Design和Decision有最基本的认识了，缓存和高性能有着千丝万缕的关系，需要深入到边边角角，既能从高层知道如何设计一个Cache，也能从底层知道如何实现一个Cache，否则在工程中可能因为一个参数配置就会导致性能问题。虽然以上方法在使用起来非常简单，但是合理的理解其设计和抽象对使用产生很大帮助，对不同API也能触类旁通，也可以提高自己设计API的水平，从此脱离API Caller的窘境，成为一名API Designer. </p>
<p>API Caller还有一个非常典型的例子是线程池的使用。API Caller还有特点不喜欢看API文档，甚至不知道哪里看API文档。</p>
<p>个人比较喜欢的学习技术方法是：无论如何先看一遍官方文档，学有余力则看一遍API文档，很感兴趣则可以入手源码。</p>
<h1 id="Copy-Paste"><a href="#Copy-Paste" class="headerlink" title="Copy Paste"></a>Copy Paste</h1><p>粘贴复制本身其实没有什么问题，可以提供编程效率，但是由于复制带来的<strong>代码重复</strong>问题较为严重。因为这是时空级别的重复，虽然重复的概念很简单，但是衍生带来的，维护性，可读性，耦合性，内聚性问题，牵一发而不知道影响面，会极大降低代码仓库质量和Bug数量。如果说技术债最严重的问题，我觉得是重复代码问题。通过良好的抽象和封装，以及子函数，状态聚合，行为聚合等编程手段，会减少重复问题。</p>
<h1 id="技术方案与实现的不一致性"><a href="#技术方案与实现的不一致性" class="headerlink" title="技术方案与实现的不一致性"></a>技术方案与实现的不一致性</h1><p>技术方案更偏向于架构，而实现更偏向于代码。有些技术方案涉及到编程(比如redis使用)，有些则无需（比如nginx负载均衡和容器化）这两者在某些程度并不是一致的。有些时候技术方案提出者并不是实现者，即使是，也有可能出现方案很牛逼，但是编码能力有限会导致的实现不好的现象。这点有一个例子，比如架构上引入缓存作为一个高层次的组件，但是缓存具体选型和实现上，则会出现分歧，用ConcurrentHashMap还是Guava Cache呢？这两者对于代码实现的复杂度不同。在实现的时候，又会面临如何封装，代码包组织，如何抽象的编程等非常细节问题，如果使用了Guava Cache，则会不会沦为API Caller的窘境呢？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>crud boy，api caller，copy paste在开发业务时候会带来巨大便利，但是使用和理解不好也会造成非常多技术债和坑，这对个人成长帮助有限，会带来<strong>我不断在学习</strong>的假象，实际难逃轮回，凡所有相，皆是虚妄，若见诸相非相，即见如来。多花些时间研究API(包括优质和劣质)是有帮助的，要对业内“<strong>忘记了，百度下就能知道了</strong>”如此言论保持怀疑，他会使你真正成为API Caller的。你我都在路上！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>代码设计杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor设计与实现</title>
    <url>/2020/11/10/ThreadPoolExecutor-API-explain/</url>
    <content><![CDATA[<p>​      线程池是Java并发包中的重要部分，也是高并发程序必不可少的类库，但是线程池技术本身比较复杂，不同语言对其实现提供的抽象也不一样，所以本文以Java线程池为例，分析它的设计与实现，以及它所带我们的抽象。</p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我对线程池的认识经历了以下三个阶段</p>
<p>1   会使用Executors的API，觉得很cool，很简单。</p>
<p>2   到配置线程池参数，理解线程池参数，池化资源复用，减少上下文切换，参数关系构成了线程池的执行过程。</p>
<p>3  任务，任务提交，任务执行的抽象理解，从ThreadPoolExecutor到ScheduledThreadPoolExecutor到ForkJoinPool，CompletableFuture的理解。</p>
<p>我现在的理解是：Java并发提供了三个核心抽象概念(<code>任务，任务提交和取消，任务执行</code>)，具体来说：</p>
<p>1 <strong>任务</strong>  任务的抽象从Runnable，Callable，FutureTask，到ForkJoinTask 子类RecursiveTask，RecursiveAction，以及CompletableFuture中的Completion对ForkJoinTask 的继承，对AsynchronousCompletionTask的实现。</p>
<p>2 <strong>任务提交和取消</strong>  从ExecutorService到ExecutorCompletionService，实现submit，invoke方法，核心子类：AbstractExecutorService作为骨架实现 </p>
<p>3 <strong>任务执行</strong>  从Executor到核心子类ThreadPoolExecutor(核心方法execute)，ForkjoinPool(因为重写了提交机制，所以核心方法submit和execute)，ScheduledThreadPoolExecutor也是种执行机制。纯接口包含了命令模式，模板模式，状态机模式等等。这就意味着你可以自定义提交和执行机制。体现了多种策略和实现分别，非常漂亮。</p>
<p>传统的<strong>new Thread(new Runnable).start()</strong>  将任务，任务提交，任务执行耦合起来，也没有提供任务取消的机制，显得那么得不可用，这篇博文主要以分析ThreadPoolExecutor为主，但是站在更高的抽象层次去看，会理解更深。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="任务结构"><a href="#任务结构" class="headerlink" title="任务结构"></a>任务结构</h2><p><img src="/images/JUC-Task-Diagram.png" alt="任务结构"></p>
<p>每个任务都有其抽象的含义，接下来我们将分析每一个接口的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表了任务执行没有结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表了一个任务执行有结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务不仅仅被执行，还可以取消，完成，返回结果，Future对任务的抽象比Runnable更加全面，要知道通过原生Thread API</span></span><br><span class="line"><span class="comment">//去取消一个任务是件复杂的事情</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//任务可以被中断取消，任务取消能力在Runnable不行的</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务返回结果，获取可能中断，也可能执行异常</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">	<span class="comment">//在指定时间内返回结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口多继承，仅仅是将Runnable和Future的能力结合起来，是一个mixin接口，但是还是强调了run的能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真正的任务实现是FutureTask，FutureTask的构造对Callable和Runnable进行包装,使得任务成为FutureTask</span></span><br><span class="line"><span class="comment">// ThreadPoolExecutor里面的实际任务是FutureTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;<span class="comment">//忽略&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;<span class="comment">//忽略&#125;</span></span><br><span class="line">    <span class="comment">//FutureTask源码在另外博客中会写，这里着重分析结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ForkJoinTask也是一种Future类型任务，其内部提供了AdaptedRunnable，AdaptedCallable的适配类，</span></span><br><span class="line"><span class="comment">//将任务适配成ForkJoinTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>从上面可以看出，在JUC中，对于任务的抽象其实和任务的执行策略有关系，ThreadPoolExecutor执行的是FutureTask任务，而ScheduledThreadPoolExecutor执行的是ScheduledFutureTask，ForkJoinPool执行的是ForkJoinTask任务，这是多么清晰且统一的设计啊！</p>
<h2 id="任务提交和执行结构"><a href="#任务提交和执行结构" class="headerlink" title="任务提交和执行结构"></a>任务提交和执行结构</h2><img src="/images/Executor-Class-Diagram.png" alt="任务提交"/>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶级接口，定义了任务执行，每一个任务是一个Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是仅仅有执行还不行，还要管理任务的取消和生命周期，所以提供了ExecutorService接口，如果说Executor定义了任务执行，</p>
<p>那么ExecutorService提供提交定义了任务的提交和取消，提供了更加完整的任务生命周期的概念，注意到在这层抽象上，我们其实并不知道具体任务是怎么执行的(并行？串行？定期)，怎么被提交的，以及怎么返回结果的，真正的实现是具体的实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Executor提供执行机制，ExecutorService提供提交，取消，完成，等待完成，批量执行任务机制，其中最核心的抽象的提交机制。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结束</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//里面结束，返回没有执行完的任务</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//提交一个Callable，返回一个加强版的任务，可以获得结果，可以取消，可以判断时候完成</span></span><br><span class="line">	&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    <span class="comment">//提交一批任务，返回所有的完成结果</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//返回任意一个结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">    <span class="comment">//继承了Executor的execute方法</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看出，在抽象层，通过一系列接口来完成“任务，任务执行，任务提交和取消”等机制，而接下来章节将分析一种提交和执行机制，线程池，也就是ThreadPoolExecutor.</p>
<h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="ThrealPoolExecutor整体结构"><a href="#ThrealPoolExecutor整体结构" class="headerlink" title="ThrealPoolExecutor整体结构"></a>ThrealPoolExecutor整体结构</h2><img src="/images/ThreadPoolExecutor.png" style="zoom:70%;" />





<h2 id="AbstractExecutorService实现"><a href="#AbstractExecutorService实现" class="headerlink" title="AbstractExecutorService实现"></a>AbstractExecutorService实现</h2><p>AbstractExecutorService仅仅为任务提交提供了骨架的实现，并没有为任务执行和取消提供实现，这也是面向接口设计的一个常用技巧，该类并没有实现Executor的execute方法，因为执行机制属于子类，我们其实可以提供默认实现。但是这样抽象类存在的价值将不是很大。</p>
<p>我们来看一下他的提交机制有哪些？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将任务包装成RunnableFuture，实际子类是FutureTask，然后子类(其实就是ThreadPoolExecutor)实现execute执行任务，最后返回执行后的任务</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交一个FutureTask，子类执行任务</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交一组任务，并且返回所有的任务返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//存放任务返回值的列表</span></span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//任务全部执行完成成功，返回futures</span></span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有完成，那么取消所有任务</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="FutureTask实现"><a href="#FutureTask实现" class="headerlink" title="FutureTask实现"></a>FutureTask实现</h2><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>该方法实现RunnableFuture，而RunnableFuture接口继承Runnable的run方法，所有本质是任务执行时候的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取任务结果"><a href="#获取任务结果" class="headerlink" title="获取任务结果"></a>获取任务结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取有限时间任务结果"><a href="#获取有限时间任务结果" class="headerlink" title="获取有限时间任务结果"></a>获取有限时间任务结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>





<h2 id="ThreadPoolExecutor-API"><a href="#ThreadPoolExecutor-API" class="headerlink" title="ThreadPoolExecutor API"></a>ThreadPoolExecutor API</h2><p>ThreadPoolExecutor 公共API较多，但是每一个都很实用。</p>
<p>我们主要分析和Executor和ExecutorService相关的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>核心构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>



<h2 id="ThreadPoolExecutor实现"><a href="#ThreadPoolExecutor实现" class="headerlink" title="ThreadPoolExecutor实现"></a>ThreadPoolExecutor实现</h2><p>ThreadPoolExecutor实现了线程池这种执行任务的机制，所以最核心的方法就是execute，如提交相关的方法，在其父类AbstractExecutorService已经实现了，所以该类其实就是实现了任务执行机制execute.</p>
<p>execute实现提供的抽象概念有，<strong>Worker</strong>和<strong>WorkQueue</strong> . Worker主要处理任务，每一个Worker是一个运行的线程，在runWoker方法中一直轮询WorkQueue的任务并执行，WorkQueue主要用于存储任务。</p>
<h3 id="公共API-execute"><a href="#公共API-execute" class="headerlink" title="公共API-execute"></a>公共API-execute</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//没有超过核心线程数，新加worker处理，此时如果添加Worker成功，直接返回，如果失败，？？？</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过核心线程数，任务入队</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务队列已满，如果添加不到workQueue里面，则拒绝任务，如果能添加，则不拒绝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="私有方法-addWorker"><a href="#私有方法-addWorker" class="headerlink" title="私有方法-addWorker"></a>私有方法-addWorker</h3><p>添加worker，并且启动worker，开始执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//添加worker</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">//启动worker</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="私有方法-addWorkerFailed"><a href="#私有方法-addWorkerFailed" class="headerlink" title="私有方法-addWorkerFailed"></a>私有方法-addWorkerFailed</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="私有非静态成员类-Worker"><a href="#私有非静态成员类-Worker" class="headerlink" title="私有非静态成员类-Worker"></a>私有非静态成员类-Worker</h3><p>Worker即是锁(extends AbstractQueuedSynchronizer)，也是一个工作者线程(implements Runnable)，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个互斥锁，且不支持重入！一个只能锁定一个任务，一个任务也只能被一个Worker锁住！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. 第一个任务，后面的任务从workQueue中拿 */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//runWokker是每个worker最核心处理方法，在该方法中，进行任务获取，任务执行</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state. The value 1 represents the locked state.</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="私有方法runWorker"><a href="#私有方法runWorker" class="headerlink" title="私有方法runWorker"></a>私有方法runWorker</h3><p>worker处理task的核心方法，从队列中不停地拿任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果是prestartAllCoreThreads，将不会进入while循环，只是start一个线程，但是不处理如何任务</span></span><br><span class="line">        <span class="comment">//task != null(少于核心线程数的任务)     task = getTask() 在阻塞队列中的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//扩展钩子方法，任务处理前的方法</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这是接口方法，客户端自定义的任务在这里执行，其实从实现来看执行的FutureTask的run方法</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">//以下异常是任务抛出的异常,如果抛出异常，则退出Main Loop，然后设置completedAbruptly=false</span></span><br><span class="line">                    <span class="comment">//此时会进入processWorkerExit方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//扩展钩子方法：任务执行后的处理</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="私有方法-processWorkerExit"><a href="#私有方法-processWorkerExit" class="headerlink" title="私有方法-processWorkerExit"></a>私有方法-processWorkerExit</h3><p>该方法用户处理Worker因为异常情况退出，比如任务抛出异常，或者Worker被中断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//删除Worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="comment">//工作的Worker大于min，则没必要替换，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动新的Worker处理任务</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="私有方法-getTask"><a href="#私有方法-getTask" class="headerlink" title="私有方法-getTask"></a>私有方法-getTask</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">	<span class="comment">//不断在阻塞获取任务</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果allowCoreThreadTimeOut是true，在keepAliveTime时间内，没有任务到来，</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="私有方法-interruptIdleWorkers"><a href="#私有方法-interruptIdleWorkers" class="headerlink" title="私有方法-interruptIdleWorkers"></a>私有方法-interruptIdleWorkers</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="公共API-shutdown"><a href="#公共API-shutdown" class="headerlink" title="公共API-shutdown"></a>公共API-shutdown</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查关闭权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//线程池状态设置为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//中断所有的空闲的Worker，此时真正执行任务的Worker不会被中断，因为获取不到锁</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="公共API-shutdownNow"><a href="#公共API-shutdownNow" class="headerlink" title="公共API-shutdownNow"></a>公共API-shutdownNow</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//workQueue中所有的任务会被取出来，然后交由客户端处理</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公共API-allowCoreThreadTimeOut"><a href="#公共API-allowCoreThreadTimeOut" class="headerlink" title="公共API-allowCoreThreadTimeOut"></a>公共API-allowCoreThreadTimeOut</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut = value;</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="公共API-prestartAllCoreThreads"><a href="#公共API-prestartAllCoreThreads" class="headerlink" title="公共API-prestartAllCoreThreads"></a>公共API-prestartAllCoreThreads</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//firstTask是null,core是true，这时候只会启动线程，但是不会执行任何任务</span></span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>







<h2 id="Executors实现"><a href="#Executors实现" class="headerlink" title="Executors实现"></a>Executors实现</h2><p>Executors是对执行者的静态工厂类，提供了常用的执行策略，并且提供了对任务的包装。</p>
<h1 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h1><h2 id="tomcat线程池解读"><a href="#tomcat线程池解读" class="headerlink" title="tomcat线程池解读"></a>tomcat线程池解读</h2><p>org.apache.tomcat.util.threads.ThreadPoolExecutor </p>
<h2 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h2><h2 id="多元化的拒绝策略"><a href="#多元化的拒绝策略" class="headerlink" title="多元化的拒绝策略"></a>多元化的拒绝策略</h2><h2 id="Apache-HttpComponents-Worker"><a href="#Apache-HttpComponents-Worker" class="headerlink" title="Apache HttpComponents Worker"></a>Apache HttpComponents Worker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkerPoolExecutor</span><br></pre></td></tr></table></figure>



<h2 id="Spring的抽象"><a href="#Spring的抽象" class="headerlink" title="Spring的抽象"></a>Spring的抽象</h2><h1 id="结论和启示"><a href="#结论和启示" class="headerlink" title="结论和启示"></a>结论和启示</h1>]]></content>
      <categories>
        <category>JDK源码</category>
        <category>Java并发框架</category>
      </categories>
      <tags>
        <tag>java.util.concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>买房犯的7个错误</title>
    <url>/2023/03/01/buy-house-mistake/</url>
    <content><![CDATA[<h1 id="合同看的不够仔细"><a href="#合同看的不够仔细" class="headerlink" title="合同看的不够仔细"></a>合同看的不够仔细</h1><p>看关键点，责任和权利对等。</p>
<h1 id="没有争取到有利于买方的合同"><a href="#没有争取到有利于买方的合同" class="headerlink" title="没有争取到有利于买方的合同"></a>没有争取到有利于买方的合同</h1><p>虽然谈了很多，细节确认了很多，但是其实并没有签一个买房合同</p>
<h1 id="违约责任不明确"><a href="#违约责任不明确" class="headerlink" title="违约责任不明确"></a>违约责任不明确</h1><p>风险规避，首先要知道可能得风险。</p>
<h1 id="价格谈的不够坚定"><a href="#价格谈的不够坚定" class="headerlink" title="价格谈的不够坚定"></a>价格谈的不够坚定</h1><p>心理战。</p>
<h1 id="中介费还可以再低"><a href="#中介费还可以再低" class="headerlink" title="中介费还可以再低"></a>中介费还可以再低</h1><p>开口3%，谈到2.85%，实际2.5%。可以找小中介。</p>
<h1 id="家居留什么没有仔细确认"><a href="#家居留什么没有仔细确认" class="headerlink" title="家居留什么没有仔细确认"></a>家居留什么没有仔细确认</h1><p>需要写到合同上。</p>
<h1 id="首付交的太早"><a href="#首付交的太早" class="headerlink" title="首付交的太早"></a>首付交的太早</h1><p>等业主解完抵押在交，几十万存短期/余额宝也有不少利息。</p>
<h1 id="其余整理"><a href="#其余整理" class="headerlink" title="其余整理"></a>其余整理</h1><p>交易方式：自行成交，中介成交，</p>
<p>买房流程：市公积金，省公积金，全款</p>
<p>谈价时间：和业主砍价，中介费，</p>
<p>贷款手续费：可以不交，打贝壳中介。</p>
<p>拆解合同思路：数字，违约事项。</p>
<p>案例分析：</p>
<p>买：全款，纯公积金，组合贷</p>
<p>卖：徐乐</p>
<p>商贷提前还款方式，时间，金额等。是否可以缩短期限，或者是缩短金额。一年内可以提前还。</p>
<p>公积金贷款提前还款方式，时间，金额等，是否可以缩短期限，或者是缩短金额。半年内可以提前还。</p>
<p>贝壳品质监督：10106188</p>
<p><strong>梳理合同的专业术语</strong></p>
<p>面签需要资料？</p>
<p>客户：身份证，户口本，银行卡，收入证明，流水，公积金异地缴存证明跟明细，私章</p>
<p>业主：夫妻双方身份证，户口本，结婚证，银行卡，房产证</p>
<p>双方都需要带原件。</p>
<p>过户需要资料？</p>
<p>挂综合号，早点排队。</p>
<p>买方（未婚）：上证人到场</p>
<p>1.上证人身份证原件</p>
<p>2.上证人户口本原件➕复印件（本人页）</p>
<p>3.储蓄卡（刷税费）</p>
<p>抽号前</p>
<p>买方提前在i西安app下载打印住房查询（必须24小时以内的），并且把查询过程录屏保存</p>
<p>或者在二楼55 56号窗口或者门口自助机打住房情况查询</p>
<p>注意:查看客户户口本的证件号是否🈶变更，🈶变更要提供身份证变更证明原件</p>
<p>查看户口本是否有撕页，撕页要盖派出所章子方可</p>
<p>【买方是否符合以下身份的两点前即可在“29号窗口”抽优先号】</p>
<p>老（80岁以上）、四级以上残疾、军人、退役军人、消防人员</p>
<p>卖方产证一人：产证人到场</p>
<p>1、产权人身份证</p>
<p>2、房产证（➕房本复印件一份）</p>
<p>3、契税票（房本满二不用带，房改房性质也不用带）</p>
<p>4、银行卡（缴税）</p>
<p>⚠️：产证人一人来，窗口问有无共有人，一定要说没有，不然无法正常过户</p>
<p>卖方在2楼55 56 60窗口或者门口自助机打登记簿一份</p>
<p>注意:业主房本通过继承、赠与、析产、判决、变更等取得的，还需要再二楼55 56 60打换证资料</p>
<p>【上证人符合以下条件的两点前即可在“29号窗口”抽优先号】</p>
<p>老（80岁以上）、四级以上残疾、军人、退役军人、消防人员</p>
<p>三方无责解约最具杀伤力。</p>
<p>先签中介合同，在签买卖合同。防止到了后面容易妥协。</p>
<p>限购 限售</p>
<p>他项权利证</p>
<p>抵押贷款</p>
<p>居住权</p>
<p>违约责任：</p>
<p>甲：房屋权利，逾期交付</p>
<p>乙：逾期付款，逾期产权转移</p>
<p>多接触几个中介，小，大可以多认识下。</p>
<p>网签需要资料：</p>
<p>刷首付第一次去了房管局二楼，没有光大银行，所以去了西安分行。</p>
<p>面签需要资料：</p>
<p>过户：可以提前排队。综合号，72号，排到了下午3点半，跑腿可以排队，买方房屋报告：24小时以内的。</p>
<p>过户需要资料</p>
<p>合同签订时间</p>
<p>解抵押提交一次性还清时间（申请解压时间）</p>
<p>注销抵押登记时间（撤压时间）</p>
<p>定金时间</p>
<p>首付时间：可以不是面签当天。</p>
<p>网签时间</p>
<p>资金监管账户开通时间</p>
<p>物业交割时间</p>
<p>银行提交资料时间（面签时间）</p>
<p>银行放款时间</p>
<p>缴税时间</p>
<p>房屋交付时间</p>
<p>网签时间</p>
<p>迁户口时间</p>
<p>贷款需要首付凭证</p>
<p><strong>我的购房时间点：</strong></p>
<p>合同签订时间 2023-02-27</p>
<p>备案时间：2023-03-13</p>
<p>购审时间：2023-03-03</p>
<p>面签时间：2023-03-13</p>
<p>资金监管协议时间：2023-03-13</p>
<p>业主申请撤压时间：2023-03-13</p>
<p>首付时间：2023-03-15</p>
<p>业主撤押时间：2023-04-04</p>
<p>银行贷款资料提交时间：2023-04-09（以为提交了，实际上缺资料，银行经理也没说，管家也没说，拖到了04-14号）</p>
<p>实际提交时间：2023-04-14</p>
<p>银行放款时间：2023-04-25</p>
<p>过户时间：2023-04-27</p>
<p>领到房产证时间：2023-05-05</p>
<p>业主全款到账时间：2023-05-05</p>
<p>交房时间：2023-05-07</p>
<p>首付：将钱存入资金监管账户。</p>
<p>首付时间：</p>
<p>买卖合同：面签当天。</p>
<p>网签合同：签订资金监管协议30天内。</p>
<p>资金监管合同：资金监管协议90天内。</p>
<p>面签当日是可以抵押没有解完的，没有解完就要首付。</p>
<p>中介不会教你如何签合同，只想让你签完，不要和业主有争论。</p>
<p>直系亲属：没有，可以12358价格举报，问下是不是强制收费。</p>
<p>合同低于2.85%出不来，贝壳规定，哪条规定，谁制定的，书面在哪里。致电贝壳服务监督电话：10106188</p>
<p>先签居间服务合同，在签买卖合同。先谈中介费，贷款，在谈买卖合同。不要到了最后一步，被别人牵着鼻子走。这一步往往买家会退让。</p>
<p>谈价格技巧。</p>
<p>小红书和实际操作以及学会威胁别人。</p>
<p>可谈的几个点 </p>
<p>选个好中介 多做对比，可以不要中介</p>
<p>贷款服务费：自愿选择实际上是强制消费</p>
<p>中介费 </p>
<p>个税</p>
<p>合同最重要的是流程以及时间节点 以及违约责任</p>
<p>开发程序去梳理下来 可视化</p>
<p>举报贝壳平台 贷款服务费 费率最低不让写 不让出合同 贝壳起到什么作用了。</p>
<p>买房不出个税 由卖房去 再去谈价格 去谈判空间 国家法律是空文</p>
<p>抓住一切谈判空间去谈。争取利益。</p>
<p>钱的地方可以谈 定金 首付 中介费 解抵押 税费 贷款服务费 签证费。整个流程也是钱流转过程。80块谁出？</p>
<p>心理价位不要告诉别人。</p>
<p>别人的话写在合同里面 不要担心麻烦 比如说家具家电问题 说了什么 都要写进去 不要不写 一个空调都谈不下来</p>
<p>买卖流程 </p>
<p>底线2个点。</p>
<p>心里底价永远不要说。</p>
<p>业主生气了 不签约了 ？？？ 中介话术太多了。因为这个 谁给陪？不配就闭嘴。</p>
<p>和业主聊什么？小区了解细节啊 环境啊 等等</p>
<p>1 成交价 2 税费 3 中介费 4 贷款服务费，影响你付出的就这四个点了。</p>
<p>中介核心问题：多接触几个，把核心问题抛出去，看看他的态度。</p>
]]></content>
      <categories>
        <category>买房</category>
        <category>买房的坑</category>
      </categories>
      <tags>
        <tag>house</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊数据同步(Redis和MySQL数据同步)</title>
    <url>/2022/09/24/data-synchronization-thinking/</url>
    <content><![CDATA[<p>数据同步问题是应用层非常值得研究的一个设计问题，也是为数不多值得研究的数据问题。虽然在实践中各种方案会运行的很好，但是这些方案背后有哪些假设，以及问题的模型是什么，这个点并没有得到充分理解，所以本文以经验之谈分析了下数据同步的设计问题，案例分析以及结论。</p>
<h1 id="数据同步的设计问题"><a href="#数据同步的设计问题" class="headerlink" title="数据同步的设计问题"></a>数据同步的设计问题</h1><p>数据同步问题是将一个地方数据，经过计算/不计算挪动到另外一个地方，在这个过程中，会面临三个问题：</p>
<ol>
<li><strong>如何同步？</strong>机器是否跨网络，是否单机，策略是双写或者是异步写？同步的是指令还是数据？双写中并发写问题如何解决？</li>
<li><strong>数据形态是什么？</strong>副本，缓存（缓存是一种特殊的副本），副本形态可能高写入，缓存形态一般高读取。</li>
<li><strong>谁来解决这个问题？</strong>应用层，还是中间件层。发起同步的进程还是后台进程？</li>
</ol>
<p>这些问题抽象为：多节点(同构或异构)数据复制带来的一致性问题。而这样问题也会受到CAP或者Jepsen中一致性的等级所制约。</p>
<p>我们来依次看看这些问题。如何同步的问题抽象是写入保证一致性，而跨网络抽象成复制问题，单机会抽象成单进程/线程读写问题，一个地方移动到另外一个地方，复制有主动/被动，有异步和同步，地点可以是内存到磁盘，可以是Redis到MySQL，可以是内存到Redis，数据的形态有副本，有缓存，不同的形态数据使用场景不同，带来的复制更新问题也不同，如缓存会有一系列缓存淘汰算法或者缓存更新策略(通读，通写，后写)，这个过程相对主动，谁来解决这个问题，影响了系统的实现。</p>
<p>如果在单机情况下，那么要保证操作同时成功，或者同时失败，数据能保证一致性，那么单机系统中最完美的抽象是事务。事务的ACID特性完美解决了一系列问题，如并发控制和恢复系统。</p>
<p>在分布式场景下，由于CAP/PACELC的限制，会导致数据同步（复制策略）不同，导致了不同的一致性级别。</p>
<p>但是面对异构系统，且跨网络的模型，原子广播协议或者分布式事务可以解决此类问题，但是谁来解决跨系统分布式事务呢？据我所知，暂时没有这样机制。即使XA模型很早提出了，Java领域也有JTA模型，但是实际系统中很少使用，因为性能或者易用性的问题。所以双写问题带来的固然局限性，因为处理异常情况非常复杂，业内也没有非常成熟的实践。</p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>案例有同构和异构系统的一致性总结。以及谁来解决这个问题来进行总结。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>如何同步</th>
<th>数据形态</th>
<th>解决层</th>
<th>CAP</th>
</tr>
</thead>
<tbody><tr>
<td>Redis 主从</td>
<td>异步复制</td>
<td>副本</td>
<td>Redis</td>
<td>AP</td>
</tr>
<tr>
<td>Redis和应用内存</td>
<td>双写，异步写</td>
<td>缓存</td>
<td>应用层</td>
<td>可选</td>
</tr>
<tr>
<td>操作系统的内存和磁盘</td>
<td>双写</td>
<td>缓存</td>
<td>操作系统层</td>
<td>CA</td>
</tr>
<tr>
<td>Redis和MySQL</td>
<td>双写，异步写</td>
<td>缓存</td>
<td>应用层</td>
<td>可选</td>
</tr>
<tr>
<td>MySQL主从</td>
<td>异步复制</td>
<td>副本</td>
<td>MySQL</td>
<td>异步AP<br />同步CP</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>ZAB协议</td>
<td>副本</td>
<td>Zookeeper</td>
<td>CP</td>
</tr>
<tr>
<td>Etcd</td>
<td>Raft协议</td>
<td>副本</td>
<td>Etcd</td>
<td>CP</td>
</tr>
<tr>
<td>MySQL 内存和磁盘</td>
<td>事务</td>
<td>缓存</td>
<td>MySQL</td>
<td>CA</td>
</tr>
</tbody></table>
<h2 id="Redis和MySQL同步分析"><a href="#Redis和MySQL同步分析" class="headerlink" title="Redis和MySQL同步分析"></a>Redis和MySQL同步分析</h2><p>同步为什么很困难？1 网络的引入导致成功，失败，不可知状态。  2  谁来解决问题，还是返回给操作方？如果没有操作方是进程呢？ 3 在同构系统同步已经很复杂但成熟，异构系统更加复杂且不成熟。4 更新操作的顺序考虑。</p>
<p>如何简化问题？忽略网络，操作方解决。</p>
<p>虽然问题分析比较有意思，但是方案来说有：</p>
<blockquote>
<ol>
<li>同步：cache-aside（缓存驻留），read through(通读)，write through（通写）等。</li>
<li>异步：单机内存队列（Sticky Available），消息中间件（请求定序），write behind（后写），Refresh ahead（预加载）等。</li>
</ol>
</blockquote>
<p>这里重点看看cache-aside模式（方案1是缓存驻留模式，其他都是对比方案）的写入方案，也是理解同步问题的起点，下面有四种模式（假设没有发生网络异常）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line">updateDB();</span><br><span class="line">deteleCache();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line">deleteCache();</span><br><span class="line">updateDB();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案3</span></span><br><span class="line">updateDB();</span><br><span class="line">updateCache();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案4</span></span><br><span class="line">updateCache();</span><br><span class="line">updateDB();</span><br></pre></td></tr></table></figure>

<p><strong>方案1，先更新数据库，后删除缓存</strong>。这个方案是常用的方案。但是会有极小概率出现这种情况：读操作没有命中缓存，会去数据库取数据，此时写请求进入，写完数据库，然后缓存失效，之前的读请求再把老数据放进去，会导致脏数据问题。这个情况理论上会出现，但是概率非常小，需要满足条件有：发生在读缓存时失效，且有并发写入，数据库写比读慢很多，所以读操作必须在写操作前进去数据库，而晚于写操作更新缓存。</p>
<p><strong>方案2，先删除缓存，后更新数据库。</strong>可能很短时间内，新的请求会读数据，然后发现缓存没有数据，就会设置缓存，导致缓存有脏数据。缓存宁愿没数据，也不要脏数据。这个概率发生要比1高很多。因为缓存模式就是读多血少。</p>
<p><strong>方案3，先更新数据库，后更新缓存。</strong>由于缓存构建可能很慢，不是简单从数据库中读取出来，更新缓存可能会非常慢，不如直接删除缓存，在下次加载时候重新计算，更是因为并发写会导致脏数据问题。因为第二个写入可能会被第一个写入覆盖了。</p>
<p><strong>方案4，先更新缓存，后更新数据库。</strong>理由同方案3。从效果上看该方案和通写一样，数据更新没有命中缓存，那么直接更新数据，如果命中缓存，那么更更新缓存，然后Cache自己更新数据库。</p>
<p>以上四种方案本质是同步方案，而没有考虑网络异常，如果网络异常导致某一个节点不可用，就会导致同步失败（为了一致性而牺牲了可用性），此时应用层有感知，虽然处理这种失败可以重试，但是如果节点是宕机呢？数据可以暂时存在本地内存队列中，等节点启动后进行同步，而要保证下次请求读到上次写入的数据，那么需要满足Jepsen中<a href="https://jepsen.io/consistency/models/read-your-writes" target="_blank" rel="noopener">Read Your Writes</a>的一致性，但是这种一致性下可用性是Sticky Available，也就是会话一致性，需要将请求定位到同一台机器，但是如果该机器宕机了，那么内存数据会丢失。完美的方案是引入事务模型来解决同时成功或者同时失败从而使得开发者忽略一切底层细节，但是代价很高且缺少分布式事务方案可以直接来用，所以引入异步方案也是一种方式，异步更新时效性没有同步那么及时，但是需要解决的问题较少，可以进行后台定时同步（类似于反熵过程），或者消息队列进行CDC或者定序（分布式提交日志）等操作进行同步，较为复杂场景是MySQL主从和Redis主从进行同步，如果是读MySQL从，而后写入Redis主，那么数据也会不一样，但是需要理解Redis对于MySQL数据形态是什么？如果Redis当做缓存，那么会有一些列缓存更新问题出现，但是缓存使用必然会带来不一致性，只是能够接受多久的不一致性时间窗口。</p>
<p>每一个种选择都会带来对应的问题，而需要仔细衡量解决问题的成本。<strong>没有完美的方案，只有削足适履的选择！</strong></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文将数据同步问题抽象成多节点数据复制带来的一致性问题。</p>
<p>所以上表可以得出结论：</p>
<ol>
<li><strong>同构的系统的同步</strong>，采用共识协议或者健壮的复制，且由系统自己解决的方案占据大多数，</li>
<li><strong>异构系统的同步</strong>，同步或者异步写都有可能，但是需要解决各自方案带来的问题，如同步需要保证同时成功，同时失败问题，而异步写需要解决系统间一致性延时问题。双写会在不同数据形态会展示不同的策略，如果数据形态是缓存，那么双写策略有通写，或者后写等缓存更新策略，还会有缓存淘汰算法等策略。一般由应用层解决较多。</li>
<li><strong>实际工程中</strong>：同步的cache-aside，通读，异步Kafka方案，或者广播消息方式，定时任务刷新是解决这类问题的有效方案。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>耗子叔 极客时间-性能设计篇之-缓存</li>
<li>微软：云计算架构设计模式 <a href="https://github.com/iambowen/cloud-design-patterns/blob/master/patterns/cache-aside.md" target="_blank" rel="noopener">Cache aside</a></li>
<li><a href="https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html</a></li>
<li>Ehcache：<a href="https://www.ehcache.org/documentation/3.3/caching-patterns.html" target="_blank" rel="noopener">https://www.ehcache.org/documentation/3.3/caching-patterns.html</a></li>
<li>耗子叔-缓存更新的套路 <a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></li>
<li>DDIA第十一章：流处理 <a href="https://github.com/Vonng/ddia/blob/master/ch11.md" target="_blank" rel="noopener">https://github.com/Vonng/ddia/blob/master/ch11.md</a></li>
<li>Hazelcast Caching Patterns：<a href="https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/" target="_blank" rel="noopener">https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/</a></li>
<li>Cache：<a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_(computing)</a></li>
<li>Cache stampede：<a href="https://en.wikipedia.org/wiki/Cache_stampede" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_stampede</a></li>
</ol>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>数据同步</tag>
        <tag>MySQL和Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-DML练习</title>
    <url>/2021/01/31/db-sql-practice/</url>
    <content><![CDATA[<ol>
<li><p>找出所有教师名字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>找出所有教师系名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select dept_name from instructor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>找出所有不重复的系名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct dept_name from instructor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>找出CS系并且工资超过7000的教师名字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> instructor <span class="keyword">where</span> dept_name=<span class="string">'CS'</span> <span class="keyword">and</span> salary&gt;<span class="number">7000</span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>找出所有教师名字，以及他们所在系的建筑名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,instructor.dept_name,building from instructor,department where instructor.dept_name&#x3D;department.dept_name;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>找出CS系的教师名和课程ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,course_id from instructor,teaches where instructor.ID &#x3D; teaches.ID and instructor.dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>找出教师的名字和他们所教课的ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,course_id from instructor natural join teaches;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>找出教师名字和他们所教课的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,title from instructor natural join teaches,course where teaches.course_id&#x3D;course.course_id;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="9">
<li><p>找出 “工资至少比Biology系某一个教师工资要高” 的所有教师名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct T.name from instructor as T, instructor as S where T.salary &gt; S.salary and S.dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from instructor where salary &gt; some(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="10">
<li><p>找出按字母排序在Biology的所有老师</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from instructor where dept_name&#x3D;&#39;Biology&#39; order by name;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="11">
<li><p>找出工资降序，如果工资相同姓名升序的教师</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from instructor order by salary desc,name asc;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="12">
<li><p>找出工资在9000到10000的教师</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from instructor where salary between 9000 and 10000;</span><br><span class="line">select name from instructor where salary &gt;&#x3D; 9000 and salary &lt;&#x3D; 10000;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="13">
<li><p>找出Biology系授课的所有教师名字和他们所教授的课程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,course_id from instructor, teaches where instructor.ID&#x3D;teaches.ID and dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="14">
<li><p>找出2009年秋季和2010年春季的所有的课程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(select course_id from section where semester&#x3D;&#39;Fall&#39; and year&#x3D;2009) union (select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>找出2009年秋季和2010年春季的同时开课的课程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select course_id from section as S where semester=<span class="string">'Fall'</span> and year=<span class="number">2009</span> <span class="function">and <span class="title">exists</span><span class="params">(select * from section as T where  semester=<span class="string">'Spring'</span> and year=<span class="number">2010</span> and S.course_id=T.course_id)</span></span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="16">
<li><p>找出在2009年秋季开课和不在2010年春季开课的课程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id not in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="17">
<li><p>找出CS系教师平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(salary) from instructor where dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="18">
<li><p>找出2010春季讲授课程的教师总数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(distinct ID) from teaches where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="19">
<li><p>找出每个系的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select dept_name,avg(salary) from instructor group by dept_name;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="20">
<li><p>找出所有老师的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(salary) from instructor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="21">
<li><p>找出每个系在2010年春季讲授一门课程的教师人数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    dept_name, COUNT(DISTINCT ID)</span><br><span class="line">FROM</span><br><span class="line">    instructor</span><br><span class="line">        NATURAL JOIN</span><br><span class="line">    teaches</span><br><span class="line">WHERE</span><br><span class="line">    semester &#x3D; &#39;Spring&#39; AND year &#x3D; 2010</span><br><span class="line">GROUP BY dept_name;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="22">
<li><p>找出教师平均工资超过42000美元的系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    dept_name, AVG(salary)</span><br><span class="line">FROM</span><br><span class="line">    instructor</span><br><span class="line">GROUP BY dept_name</span><br><span class="line">HAVING AVG(salary) &gt; 42000;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="23">
<li><p>找出2009年讲授的每个课程段，如果该课程段至少两名学生选课，找出选修该课程段的所有学生总学分的平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    course_id, semester, year, sec_id, AVG(tot_cred)</span><br><span class="line">FROM</span><br><span class="line">    takes</span><br><span class="line">        NATURAL JOIN</span><br><span class="line">    student</span><br><span class="line">WHERE</span><br><span class="line">    year &#x3D; 2009</span><br><span class="line">GROUP BY course_id , semester , year , sec_id</span><br><span class="line">HAVING COUNT(ID) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="24">
<li><p>找出既不叫Bob也不叫Ali的教师名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct name from instructor where name not in(&#39;Bob&#39;,&#39;Ali&#39;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="25">
<li><p>找出不同的学生总数，选修ID为10101教师所教授的课程段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    COUNT(DISTINCT ID)</span><br><span class="line">FROM</span><br><span class="line">    takes</span><br><span class="line">WHERE</span><br><span class="line">    (course_id , sec_id, year) IN (SELECT </span><br><span class="line">            course_id, sec_id, year</span><br><span class="line">        FROM</span><br><span class="line">            teaches</span><br><span class="line">        WHERE</span><br><span class="line">            teaches.ID &#x3D; 10101);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="26">
<li><p>找出 “工资比Biology系所有教师工资要高” 的所有教师名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from instructor where salary &gt; all(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出平均工资大于所有系平均工资的系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select dept_name from instructor group by dept_name having avg(salary) &gt;&#x3D; all(select avg(salary) from instructor group by dept_name);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="28">
<li><p>找出选修了Biology系所开设的所有课程的学生</p>
</li>
<li><p>找出所有在2009年最多开设一次的课程</p>
</li>
<li><p>找出所有在2009年最少开设两次的课程</p>
</li>
<li><p>找出系平均工资超过42000美元的那些系中的教师平均工资</p>
</li>
<li><p>所有系工资总额最大系</p>
</li>
<li><p>所有系和他们拥有的教师数</p>
</li>
<li><p>删除工作在Watson大楼系工作的教师</p>
</li>
<li><p>删除平均工资低于大学平均工资的教师</p>
</li>
<li><p>让CS系修满144学分的学生成为CS系的老师，并且其平均工资为8000</p>
</li>
<li><p>工资低于1000教师工资增加5%</p>
</li>
<li><p>工资低于平均数的教师工资增加5%</p>
</li>
<li><p>工资超过1000教师涨5%，其余增长8%</p>
</li>
<li><p>一个学生在某门课成绩既不是F，也不是空，认为修完了该课程</p>
</li>
<li><p>找出所有课程一门也没选修的学生</p>
</li>
<li><p>找出CS系所有学生以及他们在2009年春季选修的所有课程</p>
</li>
</ol>
<p>其他联系平台</p>
<p><a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">https://www.nowcoder.com/ta/sql</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统研究泛型模板</title>
    <url>/2021/04/24/distributed-systems-research-paradigm/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>世界上很多种分布式系统，如分布式文件系统，分布式KV，Google三驾马车，dynamo，newsql，分布式应用系统(微服务与SOA)，WWW等等，每种分布式系统种类不同，但是面临的问题类似，这里总结研究这些系统面临的共同话题，以便于研究新系统时候能够举一反三。泛型出自《分布式系统原理与泛型》这本书。当我们面临一个新的分布式系统时候，通过这些角度思考，能对系统有更深理解。</p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><table>
<thead>
<tr>
<th>分布式系统的抽象</th>
<th>问题</th>
</tr>
</thead>
<tbody><tr>
<td>系统体系结构</td>
<td>系统体系结构是什么？<br />静态和动态视图是什么？<br />系统接口是什么？</td>
</tr>
<tr>
<td>进程</td>
<td>进程模型是什么？<br />有哪些核心进程？<br />系统参与者有哪些？<br />进程可能奔溃？<br />进程如何工作完成系统功能？</td>
</tr>
<tr>
<td>通信</td>
<td>系统间如何通信？<br />系统对外如何通信？<br />同步还是异步？<br />传递保证是什么？</td>
</tr>
<tr>
<td>命名</td>
<td>如何找到资源？</td>
</tr>
<tr>
<td>协调</td>
<td>进程间如何同步和协作？<br />如何互斥？<br />如何达成共识？<br /></td>
</tr>
<tr>
<td>一致性和复制</td>
<td>一致性级别是什么？<br />复制过程是什么？(写入，副本更新，读取过程是什么？) <br />数据分区过程是什么？</td>
</tr>
<tr>
<td>容错性</td>
<td>如何检查故障？<br />故障恢复过程是什么？<br />网络分区怎么处理？<br />系统成员变动如何处理？<br />分布式提交过程是什么？</td>
</tr>
<tr>
<td>安全</td>
<td>系统间通信安全如何保证？<br />系统安全如何保证？</td>
</tr>
</tbody></table>
<h2 id="系统体系结构-Architecture"><a href="#系统体系结构-Architecture" class="headerlink" title="系统体系结构(Architecture)"></a>系统体系结构(Architecture)</h2><p>系统结构：集中式，非集中式，混合式</p>
<p>系统风格：分层架构，面向对象和SOA架构，面向资源架构，发布订阅架构</p>
<h2 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程(Process)"></a>进程(Process)</h2><p>进程模型有多线程，单线程进程，有限状态机等内容</p>
<h2 id="通信-Communication"><a href="#通信-Communication" class="headerlink" title="通信(Communication)"></a>通信(Communication)</h2><p>rpc</p>
<p>面向消息：AMQP</p>
<p>面向流</p>
<p>多播通信（应用层基于树的多播，flooding 多播，gossip data dissemination（传播））</p>
<h2 id="命名-Naming"><a href="#命名-Naming" class="headerlink" title="命名(Naming)"></a>命名(Naming)</h2><p>名称，标识，地址，找到资源的方法</p>
<p>无层次命名：DHT，home-base，等级划分</p>
<p>结构化命名：NFS</p>
<p>基于属性命名：LDAP</p>
<h2 id="协调-Coordination"><a href="#协调-Coordination" class="headerlink" title="协调(Coordination)"></a>协调(Coordination)</h2><p>时钟同步：物理时钟</p>
<p>逻辑时钟：Lamport逻辑时钟，向量时钟</p>
<p>互斥：集中，非集中，分布式，令牌环</p>
<p>选举</p>
<h2 id="一致性和复制-Consistency-and-Replication"><a href="#一致性和复制-Consistency-and-Replication" class="headerlink" title="一致性和复制(Consistency and Replication)"></a>一致性和复制(Consistency and Replication)</h2><p>一致性协议，最终一致性，单调读，单调写，读写一致性，写读一致性，强最终一致性，线性一致性，顺序一致性，因果一致性等内容</p>
<p>复制：主从复制，多主复制，无主复制</p>
<h2 id="容错性-Fault-tolerance"><a href="#容错性-Fault-tolerance" class="headerlink" title="容错性(Fault tolerance)"></a>容错性(Fault tolerance)</h2><p>故障类型，进程恢复，可靠通信，组通信（原子多播），分布式提交，恢复，故障检测</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全通道，访问控制，安全管理</p>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><p>《分布式系统原理与泛型》第二版和第三版</p>
<p>《分布式系统概念与设计》</p>
<p>《数据库系统内幕》</p>
<p>《数据密集型应用系统设计》</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务解决方案</title>
    <url>/2022/01/01/distributed-transaction/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式事务划分为两个角度，1是存储层，也即数据库角度的分布式事务，多实现于分布式数据库事务 2是业务层，偏向于服务化系统以及业务系统的分布式事务。</p>
<h1 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h1><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">spanner</a>，<a href="https://en.wikipedia.org/wiki/X/Open_XA" target="_blank" rel="noopener">XA</a>(<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">2pc</a>)，，<a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">3pc</a>，<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf" target="_blank" rel="noopener">percolator</a>(2pc)，<a href="http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf" target="_blank" rel="noopener">calvin</a>，<a href="https://omid.incubator.apache.org/" target="_blank" rel="noopener">apache omid</a></p>
<table>
<thead>
<tr>
<th>模型</th>
<th>数据模型</th>
<th>并发控制方案</th>
<th>隔离级别支持</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>XA</td>
<td>不限</td>
<td>两阶段锁（悲观）</td>
<td>所有隔离级别</td>
<td>加读锁导致性能下降</td>
</tr>
<tr>
<td>Percolator</td>
<td>Key-Value</td>
<td>加锁(悲观) &amp; MVCC</td>
<td>SI</td>
<td></td>
</tr>
<tr>
<td>Omid</td>
<td>Key-Value</td>
<td>冲突检测(乐观) &amp; MVCC</td>
<td>SI</td>
<td></td>
</tr>
<tr>
<td>Calvin</td>
<td>不限</td>
<td>确定性数据库</td>
<td>Serializable</td>
<td>仅适用于One-Shot事务</td>
</tr>
</tbody></table>
<h1 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h1><p>解决思路有：XA(异构系统)，TCC，Saga，基于本地消息的分布式事务，基于事务消息的分布式事务</p>
<p>具体的产品有：seata， hmily， byetcc， easytransaction,XA-JTA(atomikos,bitronix,narayana) ,JOTM, BTM, MSDTC</p>
<h2 id="同构与异构系统"><a href="#同构与异构系统" class="headerlink" title="同构与异构系统"></a>同构与异构系统</h2><p>同构：MySQL Cluster NDB，VoltDB</p>
<p>异构：MySQL和MQ，MySQL和Redis</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(1)-集群,节点与分片，理解查找过程</title>
    <url>/2021/08/29/elasticsearch-series1-common/</url>
    <content><![CDATA[<h1 id="单机多节点集群"><a href="#单机多节点集群" class="headerlink" title="单机多节点集群"></a>单机多节点集群</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;elasticsearch -E node.name&#x3D;node0 -E cluster.name&#x3D;geektime -E path.data&#x3D;node0_data -d</span><br><span class="line">.&#x2F;elasticsearch -E node.name&#x3D;node1 -E cluster.name&#x3D;geektime -E path.data&#x3D;node1_data -d</span><br><span class="line">.&#x2F;elasticsearch -E node.name&#x3D;node2 -E cluster.name&#x3D;geektime -E path.data&#x3D;node2_data -d</span><br><span class="line">.&#x2F;elasticsearch -E node.name&#x3D;node3 -E cluster.name&#x3D;geektime -E path.data&#x3D;node3_data -d</span><br></pre></td></tr></table></figure>



<p>可以通过<code>GET /_cat/nodes?v</code>查看node0是主节点。</p>
<h1 id="创建索引与分片"><a href="#创建索引与分片" class="headerlink" title="创建索引与分片"></a>创建索引与分片</h1><p>es在一个有4个节点的集群上创建一个索引，并且索引里面只包含了一个文档，那么这份文档的存储和节点分布是什么样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE test</span><br><span class="line">PUT test</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 3,</span><br><span class="line">    &quot;number_of_replicas&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际在4个节点总共有9个分片，3个主分片，6个副本分片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;company&quot;:&quot;baidu&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;, </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;company&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;baidu&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看索引在节点的分配</span><br><span class="line">GET &#x2F;_cat&#x2F;shards?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index shard prirep state   docs store ip        node</span><br><span class="line">test  1     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class="line">test  1     p      STARTED    0  230b 127.0.0.1 node3</span><br><span class="line">test  1     r      STARTED    0  230b 127.0.0.1 node0</span><br><span class="line">test  2     r      STARTED    0  230b 127.0.0.1 node1</span><br><span class="line">test  2     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class="line">test  2     p      STARTED    0  230b 127.0.0.1 node0</span><br><span class="line">test  0     r      STARTED    1 3.4kb 127.0.0.1 node1</span><br><span class="line">test  0     p      STARTED    1 3.4kb 127.0.0.1 node2</span><br><span class="line">test  0     r      STARTED    1 3.4kb 127.0.0.1 node3</span><br></pre></td></tr></table></figure>



<img src="/images/shard-legend.png"/>



<p>可以看到创建一个索引的时候，被分配到4个node，node0是主节点leader节点(图片有星号)，node2~node4是非leader节点。而company=baidu文档被创建时候，被分片到node1，node2，node3上面（docs=1），<strong>每一个文档被分配到一个分片</strong>，node2是primary shard，而node1，node3是replica shard. 而在搜索company=baidu时候，打开profile api，会发现数据查找经历了3个shard，分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;id&quot; : &quot;[S_H7_aQZQT6N1Xvak3Y5Gg][test][1]&quot;</span><br><span class="line">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][0]&quot;</span><br><span class="line">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][2]&quot;</span><br></pre></td></tr></table></figure>

<p>根据<code>GET /_nodes/_all/nodes</code> 可以获取到节点名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node0：uvCcgxEFT82xFtQAv9aydA</span><br><span class="line">node1：Y6x8KA6XQzaa4ebI2QKrZg</span><br><span class="line">node2：S_H7_aQZQT6N1Xvak3Y5Gg</span><br><span class="line">node3：BdHl3TItTv6B4BHm1DuwMA</span><br></pre></td></tr></table></figure>

<p>可以得知，查找company=baidu时候，一定会查找三个分片（也就是<strong>number_of_shards</strong>的个数，primary和replica都有可能），profile api显示经历了1次node2[1]和2次node1[0]，node1[2]，恰好查找了三个分片0,1,2。但是文档存储在node1[0]，node2[0]，node3[0]，所以数据最终在node1[0]分片(<strong>replica shard</strong>)上找到了要查找的文档，在node1[2]，node2[1]并没有找到文档。每次重新执行的查找的时候，profile api也会动态变化，查询的节点和分片也会随之变化。（疑问：如果有50个节点，一个索引创建了3个分片(number_of_shards=3)，那么怎么知道需要遍历分片在哪里呢？而不是所有节点遍历一遍，也就是es怎么知道遍历哪些节点呢？所以es一定存了分片和）</p>
<h1 id="索引常用DSL"><a href="#索引常用DSL" class="headerlink" title="索引常用DSL"></a>索引常用DSL</h1><h2 id="查看节点详情"><a href="#查看节点详情" class="headerlink" title="查看节点详情"></a>查看节点详情</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_nodes</span><br></pre></td></tr></table></figure>



<h2 id="查看索引映射和配置"><a href="#查看索引映射和配置" class="headerlink" title="查看索引映射和配置"></a>查看索引映射和配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET test</span><br></pre></td></tr></table></figure>



<h2 id="查看索引大小"><a href="#查看索引大小" class="headerlink" title="查看索引大小"></a>查看索引大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;indices?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>



<h2 id="查看segment"><a href="#查看segment" class="headerlink" title="查看segment"></a>查看segment</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;segments?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式系统</category>
        <category>搜索</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>分布式系统泛型</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(2)-query的match和term区别</title>
    <url>/2021/08/29/elasticsearch-series2-match-term/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>match query在索引和查询时分词，term query在索引时候分词，在查询时候不分词。</p>
<p>match query是全文搜索，term query是词项搜索。</p>
<p>match query不是精确搜索，想要精确搜索，使用term keyword query.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE test</span><br><span class="line">PUT test&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;content&quot;:&quot;Hello World&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="match-query"><a href="#match-query" class="headerlink" title="match query"></a>match query</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有结果返回。es的standard分词器会将Hello World索引数据时候，会分解成hello，world.</p>
<p>而match query会将content进行分词为hello，world。所以可以搜到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有结果返回。match query会将内容进行分词为hello，world，所以可以查到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无结果返回。match query keyword会将match query转换为term query，keyword搜索并不会分词，所以搜索不到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有结果返回。match query会分词，将match query转换为term query</p>
<h1 id="term-query"><a href="#term-query" class="headerlink" title="term query"></a>term query</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无结果返回。term query不会分词，hello world查询不到，因为index时候Hello World被转换成hello，world.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无结果返回。term query不会分词，数据在content被分成了hello，world.hello world查询不到，因为index时候Hello World被转换成hello，world.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无结果返回，没有hello world，索引时候Hello World分解成hello，world两个词.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有结果返回。精确匹配。term query的精确匹配用keyword。</p>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>搜索</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>分布式系统泛型</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>guava-retry源码分析</title>
    <url>/2020/08/15/guava-retry-code-analysis/</url>
    <content><![CDATA[<p>guava-retry是扩展guava的一个重试库。</p>
<h3 id="一-问题-Question"><a href="#一-问题-Question" class="headerlink" title="一  问题(Question)"></a>一  问题(Question)</h3><p>在系统设计的时候，重试作为系统容错方法，被广泛使用在云化系统，微服务系统，并以模式形式记录在 <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry" target="_blank" rel="noopener">azure cloud design pattern</a>从而使得系统变得更加健壮和弹性(resilient)，同时和熔断，限流等策略结合起来，充分保证系统可靠性。但是如何设计一个可复用，可扩展的重试库，需要先了解重试的设计问题。业界给出的答案有：<a href="https://github.com/rholder/guava-retrying" target="_blank" rel="noopener">guava-retry</a>，<a href="https://mvnrepository.com/artifact/org.springframework.retry/spring-retry" target="_blank" rel="noopener">Spring Retry</a> ，<a href="https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-retry" target="_blank" rel="noopener">Resilience4j</a> ，本文主要对guava-retry进行分析。</p>
<h3 id="二-设计-Design"><a href="#二-设计-Design" class="headerlink" title="二  设计(Design)"></a>二  设计(Design)</h3><p>重试的设计问题有以下几个方面：</p>
<ul>
<li><p>1   什么时候开始重试？ 异常和错误或不满足预期值。</p>
</li>
<li><p>2   重试策略是什么？ 重试策略可以具体划分一下三个方面：</p>
<p>​          2.1 基于次数(空间)还是基于时间，还是两者结合起来</p>
<p>​          2.2 重试间隔策略是什么？是等待指定时间后重试，还是无限重试，还是指数回退呢</p>
</li>
<li><p>3   什么时候停止重试？</p>
</li>
</ul>
<h3 id="三-抽象和分解-Abstract-and-Decomposing"><a href="#三-抽象和分解-Abstract-and-Decomposing" class="headerlink" title="三 抽象和分解(Abstract and Decomposing)"></a>三 抽象和分解(Abstract and Decomposing)</h3><p>通过对问题的理解，可以抽象出核心概念和隐喻解决这个问题。来看看guava-retry的抽象和解决之道。</p>
<ol>
<li><p>执行过程抽象成Callable对象，执行时间控制通过TimeLimiter来管理。</p>
</li>
<li><p>将通过对返回结果封装成Attempt对象，来表达结果是否有异常，获取该结果已经重试次数，距离第一次重试耗费多久。</p>
</li>
<li><p>将重试条件组合成Predicate对象。</p>
</li>
<li><p>等待策略WaitStrategy获取等待时间，阻塞策略BlockStrategy用于重试间隔的阻塞，停止策略StopStrategy。以及提供了默认策略实现的WaitStrategies工厂，BlockStrategys工厂，StopStrategys工厂。</p>
</li>
<li><p>RetryListener监听器，监听每次重试时候的动作。</p>
</li>
<li><p>RetryerBuilder用于构造Retryer，Retryer将条件，过程，策略通过call(Callable<V> callable)方法组合起来，来完成整个重试机制的实现。</p>
</li>
</ol>
<h3 id="四-类图-Class-Diagram"><a href="#四-类图-Class-Diagram" class="headerlink" title="四 类图(Class Diagram)"></a>四 类图(Class Diagram)</h3><p><img src="/images/guava-retry.png" alt="类图"></p>
<h3 id="五-核心流程-Core-process"><a href="#五-核心流程-Core-process" class="headerlink" title="五 核心流程(Core process)"></a>五 核心流程(Core process)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Retryer类的核心流程call方法中，将RetryerBuilder中的等待条件，执行过程(指定时间执行完成)，等待策略，阻塞策略，</span></span><br><span class="line"><span class="comment">//停止策略整合起来完成重试机制的设计。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">(Callable&lt;V&gt; callable)</span> <span class="keyword">throws</span> ExecutionException, RetryException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    <span class="comment">//for循环中不断重试，并通过attemptNumber来记录重试次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> attemptNumber = <span class="number">1</span>; ; attemptNumber++) &#123;</span><br><span class="line">        Attempt&lt;V&gt; attempt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//指定时间内返回结果</span></span><br><span class="line">            V result = attemptTimeLimiter.call(callable);</span><br><span class="line">            <span class="comment">//正常返回结果封装成ResultAttempt对象，并且记录真实结果，重试吃啥，距离第一次返回结果的时间间隔</span></span><br><span class="line">            attempt = <span class="keyword">new</span> ResultAttempt&lt;V&gt;(result, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//异常返回结果封装成ExceptionAttempt对象</span></span><br><span class="line">            attempt = <span class="keyword">new</span> ExceptionAttempt&lt;V&gt;(t, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//监听器回调Attempt结果</span></span><br><span class="line">        <span class="keyword">for</span> (RetryListener listener : listeners) &#123;</span><br><span class="line">            listener.onRetry(attempt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//各种重试条件(结果预期，抛出异常，状态码非200等判断)组合Predicate判断，是否需要重试</span></span><br><span class="line">        <span class="keyword">if</span> (!rejectionPredicate.apply(attempt)) &#123;</span><br><span class="line">            <span class="comment">//不需要重试直接返回真实结果</span></span><br><span class="line">            <span class="keyword">return</span> attempt.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要重试时候判断此次是否停止重试</span></span><br><span class="line">        <span class="keyword">if</span> (stopStrategy.shouldStop(attempt)) &#123;</span><br><span class="line">            <span class="comment">//停止重试时候，说明正确返回值还没有获取，即认为重试失败，抛出重试异常，交由客户端处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RetryException(attemptNumber, attempt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//等待策略获取等待时间</span></span><br><span class="line">            <span class="keyword">long</span> sleepTime = waitStrategy.computeSleepTime(attempt);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//开始等待</span></span><br><span class="line">                blockStrategy.block(sleepTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//线程等待中被中断，抛出重试异常</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RetryException(attemptNumber, attempt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六-总结-Summary"><a href="#六-总结-Summary" class="headerlink" title="六 总结(Summary)"></a>六 总结(Summary)</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>设计上：</p>
<ol>
<li>整个源码总共13个类，6个接口,  7个类中4个工厂类，1个异常类，2个核心类，1个监听类。抽象度比较平衡，类的层次最多两层。</li>
<li>整个源码非常简洁，容易理解，代码重复很少，对外API也很简单容易使用。</li>
<li>guava-retry使用Builder，Template，Strategy，Factory，Facade等模式将整个流程组合起来，并且提供了扩展点以自定义策略。体现了面向接口编程原则。</li>
</ol>
<p>实现上：</p>
<ol>
<li>使用Guava的SimpleTimeLimiter，Preconditions，Predicates。</li>
<li>引入findbugs:jsr305注解，@Immutable，@Nonnull注解，提高可读性和设计意图。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>官方issue较多，回复不及时，不是很活跃。</li>
<li>SimpleTimeLimiter类在Guava中已经没有公开构造方法了，所以使用时候会报运行时错误。</li>
<li>虽然叫guava-retry，但是实际不是google维护的代码。</li>
<li>单元测试不全面，有些类没有测试。</li>
<li>代码检测不如apache标准项目多，比如pmd，checkstyle等检测。</li>
<li>由于是个人项目，工程规范方面可借鉴的较少。</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>guava-retry</tag>
      </tags>
  </entry>
  <entry>
    <title>Java应用组成集群的方式探索</title>
    <url>/2021/12/20/java-application-cluster/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要讨论<strong>分布式业务系统</strong>(有别于分布式存储系统)中的组建集群方式，系统高可用的方式是节点冗余，而节点冗余本身并不需要保证节点互相通信，常用的方式是节点注册到注册中心，也即节点是无状态的，这是最简单的分布式模型，集群模式是在此模型上加了稍许复杂度，但是对于业务系统想要组成集群的话，需要集群间通信。本文主要探讨分布式业务系统组成集群的方法，而不是探讨集群模式下的具体功能设计(如分片，Workqueue，Sactter/Gather, Scale out等功能)。这里<strong>集群定义</strong>我认为需要<strong>满足两个基本条件</strong>：</p>
<ol>
<li><strong>必须有membership change的能力。</strong>节点增加，移除，宕机对集群可感知。</li>
<li><strong>必须有协调机制。</strong>这里可以认为是Leader Select或者Primary Select能力，当然Amazon的Dynamo是通过Gossip实现的P2P系统并没有Leader节点。</li>
</ol>
<p>满足上述集群定义则系统会满足：</p>
<p><strong>高可用 -&gt;  复制(Replication)  -&gt;  一致性(Consistency)  -&gt;  共识(Consensus)</strong></p>
<p>系统间通信方式有rpc，mq，系统体系结构有单机，多机（主从，对等，集群），而Java应用组成集群方式总结如下：</p>
<ol>
<li>借助单机/分布式存储：etcd/zookeeper/nacos/consul/<a href="https://github.com/ha/doozerd" target="_blank" rel="noopener">doozerd</a>/mysql/<a href="https://moosefs.com/" target="_blank" rel="noopener">MFS</a>/NFS</li>
<li>借助中间件/框架：Hazelcast，Akka，<a href="https://www.serf.io/" target="_blank" rel="noopener">Serf</a>(Gossip)，<a href="http://www.jgroups.org/overview.html" target="_blank" rel="noopener"><strong>JGroups</strong></a> , <a href="https://www.erlang.org/doc/reference_manual/distributed.html" target="_blank" rel="noopener"><strong>Erlang/OTP(非Java)</strong></a></li>
<li>借助协议：raft，gossip，zab，paxos。需要利用开源实现来构建系统。</li>
</ol>
<h1 id="借助存储"><a href="#借助存储" class="headerlink" title="借助存储"></a>借助存储</h1><p>借助存储，一般会采用etcd/zk这种方式较多，可以非常方便实现Leader选举，任务分发，任务调度，分布式锁，分布式队列等功能，并且membership change可以检测到。当然用Redis也可以实现类似功能，但是redis实现membership change需要额外开发，本身并不支持。</p>
<h1 id="借助中间件-框架"><a href="#借助中间件-框架" class="headerlink" title="借助中间件/框架"></a>借助中间件/框架</h1><p>Hazelcast也可以实现Leader选举，分布式弹性计算，分布式内存Map/List/Set等功能，应用系统借助嵌入式hazelcast便可以方便集成。或者Hazelcast竞品<a href="https://atomix.io/docs/latest/getting-started/" target="_blank" rel="noopener">Atomix</a>, <a href="https://ignite.apache.org/" target="_blank" rel="noopener">Apache Ignite</a></p>
<p>Akka的<a href="https://doc.akka.io/docs/akka/current/typed/cluster.html" target="_blank" rel="noopener">Cluster</a>，<a href="https://doc.akka.io/docs/akka/current/typed/cluster-singleton.html" target="_blank" rel="noopener">Cluster Singleton</a>, <a href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html" target="_blank" rel="noopener">Cluster Sharding</a>，<a href="https://doc.akka.io/docs/akka/current/typed/distributed-data.html" target="_blank" rel="noopener">Distributed Data</a>功能非常强大，非常适合节点组建集群，用于解决集群单例，分片等问题。</p>
<p>JGroups是Java的组通信框架，也可以实现集群成员变更，其官方有基于<a href="http://www.jgroups.org/hsqldbr.html" target="_blank" rel="noopener"><strong>HSQLDB+JGroup</strong></a>的例子，<a href="http://www.jgroups.org/taskdistribution.html" target="_blank" rel="noopener"><strong>任务分发系统</strong></a>,  <a href="http://www.jgroups.org/replcache.html" target="_blank" rel="noopener"><strong>ReplicationCache</strong></a>。</p>
<h1 id="借助协议"><a href="#借助协议" class="headerlink" title="借助协议"></a>借助协议</h1><p>借助协议实现较为复杂，但是灵活性最大。需要引入协议的实现库，并且自己构建业务系统，常用的Raft Plus的方式，Raft+业务系统，当然可以实现Raft协议本身的功能，比如选举，集群成员变更，具体取决于协议的实现，比如协议是否实现节点通信以及日志存储等功能，如etcd-raft用起来比较难，但是既然用了etcd-raft，为什么不直接用etcd呢？其他存储层Raft Plus方案还有，raft+redis=<a href="https://github.com/RedisLabs/redisraft" target="_blank" rel="noopener">redisraft</a>，raft+rocksdb=tikv，raft+sqllite=<a href="https://github.com/rqlite/rqlite" target="_blank" rel="noopener">rqlite</a>，<a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">hashicorp-raft</a>+boltdb=consul，mysql+paxos= MGR，这里只是参考，相比较存储层，在业务层用raft会简单一些。这里推荐Java的raft实现蚂蚁金服的<a href="https://www.sofastack.tech/projects/sofa-jraft/overview/" target="_blank" rel="noopener">sofa-jraft</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文探讨了业务层组建集群方式，业务层组建集群相比较存储层组建集群要简单，因为存储层往往需要分布式事务+数据复制带来一致性的这些语义，而业务层相对来说弱化了这些语义，由下层基础设施保证。我认为相比较而言业务层组建集群方式以下更优：借助存储方案是etcd/zk(curator)，借助中间件/框架是Akka和Hazelcast，借助协议是Raft Plus.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>hazelcast和ignite对比：<a href="https://hazelcast.com/resources/hazelcast-vs-gridgain/" target="_blank" rel="noopener">https://hazelcast.com/resources/hazelcast-vs-gridgain/</a></li>
<li>《分布式系统设计》- Brendan Burns <a href="https://github.com/brendandburns/designing-distributed-systems" target="_blank" rel="noopener">designing-distributed-systems</a></li>
<li>《云计算架构设计模式》- Microsoft <a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li>
<li>《Akka应用模式-分布式应用程序设计实践指南》- Michael Nash</li>
<li>《高伸缩性系统 Erlang/OTP大型分布式容错设计》- Francesco Cesar</li>
<li>分布式系统研究泛型模板 <a href="https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/" target="_blank" rel="noopener">https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/</a></li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
        <category>应用集群</category>
      </categories>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(3)- 聚合查询性能优化：从terms聚合到composite聚合</title>
    <url>/2021/08/29/elasticsearch-series3-terms-composite-aggregation/</url>
    <content><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>查找19年到现在数据很慢，terms聚合性能问题。订单量统计(2021-11-11⽇统计) 来⾃：X_N表。</p>
<table>
<thead>
<tr>
<th>项⽬</th>
<th>订单量</th>
</tr>
</thead>
<tbody><tr>
<td>X1</td>
<td>176386</td>
</tr>
<tr>
<td>X2</td>
<td>774911</td>
</tr>
<tr>
<td>X3</td>
<td>1183295</td>
</tr>
<tr>
<td>X4</td>
<td>1567748</td>
</tr>
<tr>
<td>X5</td>
<td>3567914</td>
</tr>
</tbody></table>
<p>当订单量达到500w-1000w以上，terms聚合性能很差。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>性能优化是把es的terms-aggregation改成composite aggregation。terms嵌套聚合改成composite聚合的<strong>缺点：相对嵌套式terms，缺乏的功能是⽆法执⾏中间层上的⼦聚合，需要再对中间层进⾏额外的聚合请求。所以会极⼤增加代码的编写</strong>。</p>
<p><strong>terms</strong>聚合：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>terms</strong>聚合不精确问题(5.3有说明)：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.3/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-approximate-counts" target="_blank" rel="noopener">参考</a></p>
<p><strong>composite聚合</strong>：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>multi-terms聚合</strong>(7.15才有特性)：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-multi-terms-aggregation.html" target="_blank" rel="noopener">参考</a></p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, Cat1Agg&gt;&gt; aggs(String index, Param param) &#123;</span><br><span class="line">        AggregationBuilder amountAgg = AggregationBuilders.sum(<span class="string">"amount"</span>).field(<span class="string">"amount"</span>);</span><br><span class="line">        AggregationBuilder vendorModeAgg = AggregationBuilders.terms(<span class="string">"vendorMode"</span>).field(<span class="string">"vendorMode"</span>)</span><br><span class="line">                .size(<span class="number">1000</span>).shardSize(<span class="number">1000</span>).collectMode(BREADTH_FIRST)</span><br><span class="line">                .subAggregation(amountAgg);</span><br><span class="line">        AggregationBuilder categoryAgg = AggregationBuilders.terms(<span class="string">"category"</span>).field(<span class="string">"category"</span>)</span><br><span class="line">                .size(<span class="number">1000</span>).shardSize(<span class="number">1000</span>).collectMode(BREADTH_FIRST)</span><br><span class="line">                .subAggregation(amountAgg).subAggregation(vendorModeAgg);</span><br><span class="line">        AggregationBuilder category1Agg = AggregationBuilders.terms(<span class="string">"category1"</span>).field(<span class="string">"category1"</span>)</span><br><span class="line">                .size(<span class="number">1000</span>).shardSize(<span class="number">1000</span>).collectMode(BREADTH_FIRST).missing(<span class="string">"⽆分类"</span>)</span><br><span class="line">                .subAggregation(amountAgg).subAggregation(categoryAgg);</span><br><span class="line">        AggregationBuilder termAgg = AggregationBuilders.terms(<span class="string">"term"</span>).field(<span class="string">"term"</span>)</span><br><span class="line">                .size(<span class="number">1000</span>).shardSize(<span class="number">1000</span>).collectMode(BREADTH_FIRST)</span><br><span class="line">                .subAggregation(category1Agg);</span><br><span class="line">        SearchRequestBuilder req = esClient.prepareSearch(index).setSize(<span class="number">0</span>).setQuery(QueryBuilders.boolQuery().filter(param.toE</span><br><span class="line">                .addAggregation(termAgg);</span><br><span class="line">        SearchResponse res = req.get(Es.TimeOut_30m);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) log.trace(<span class="string">"⽀付⾦额（含退款）流⽔统计:&#123;&#125;\n&#123;&#125;"</span>, req, res);</span><br><span class="line">        Map&lt;Integer, Map&lt;String, Cat1Agg&gt;&gt; statis = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        Terms termRsts = res.getAggregations().get(<span class="string">"term"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Terms.Bucket termRst : termRsts.getBuckets()) &#123;</span><br><span class="line">            <span class="keyword">int</span> month = termRst.getKeyAsNumber().intValue();</span><br><span class="line">            Map&lt;String, Cat1Agg&gt; monthStatis = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            Terms cat1Rsts = termRst.getAggregations().get(<span class="string">"category1"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Terms.Bucket cat1Rst : cat1Rsts.getBuckets()) &#123;</span><br><span class="line">                String cat1 = cat1Rst.getKeyAsString();</span><br><span class="line">                Cat1Agg cat1Agg = <span class="keyword">new</span> Cat1Agg();</span><br><span class="line">                cat1Agg.amount = <span class="keyword">new</span> BigDecimal(((Sum) cat1Rst.getAggregations().get(<span class="string">"amount"</span>)).getValueAsString()).setScale(<span class="number">5</span>,</span><br><span class="line">                        Terms catRsts = cat1Rst.getAggregations().get(<span class="string">"category"</span>);</span><br><span class="line">                <span class="keyword">for</span> (Terms.Bucket catRst : catRsts.getBuckets()) &#123;</span><br><span class="line">                    String cat = catRst.getKeyAsString();</span><br><span class="line">                    CatAgg catAgg = <span class="keyword">new</span> CatAgg();</span><br><span class="line">                    catAgg.amount = <span class="keyword">new</span> BigDecimal(((Sum) catRst.getAggregations().get(<span class="string">"amount"</span>)).getValueAsString()).setScale(</span><br><span class="line">                            Terms vendorModeRsts = catRst.getAggregations().get(<span class="string">"vendorMode"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (Terms.Bucket vendorModeRst : vendorModeRsts.getBuckets()) &#123;</span><br><span class="line">                        VendorMode vendorMode = IntEnum.valueOf(VendorMode<span class="class">.<span class="keyword">class</span>, <span class="title">vendorModeRst</span>.<span class="title">getKeyAsNumber</span>().<span class="title">intValue</span>())</span>;</span><br><span class="line">                        <span class="keyword">if</span> (vendorMode == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        BigDecimal amount = <span class="keyword">new</span> BigDecimal(((Sum) vendorModeRst.getAggregations().get(<span class="string">"amount"</span>)).getValueAsStri</span><br><span class="line">                                catAgg.vendorModeAmounts.put(vendorMode, amount);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cat1Agg.catAmounts.put(cat, catAgg);</span><br><span class="line">                &#125;</span><br><span class="line">                monthStatis.put(cat1, cat1Agg);</span><br><span class="line">            &#125;</span><br><span class="line">            statis.put(month, monthStatis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> statis;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="terms聚合"><a href="#terms聚合" class="headerlink" title="terms聚合"></a>terms聚合</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET order/_search?size=0&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "bool": &#123;</span><br><span class="line">            "must": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;</span><br><span class="line">                        <span class="attr">"term"</span>: &#123;</span><br><span class="line">                            <span class="attr">"gte"</span>: <span class="number">202111</span>,</span><br><span class="line">                            <span class="attr">"lte"</span>: <span class="number">202111</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs": &#123;</span><br><span class="line">        "term": &#123;</span><br><span class="line">            "terms": &#123;</span><br><span class="line">                "field": "term",</span><br><span class="line">                "size": 1000,</span><br><span class="line">                "shard_size": 1000</span><br><span class="line">            &#125;,</span><br><span class="line">            "aggs": &#123;</span><br><span class="line">                "category1": &#123;</span><br><span class="line">                    "terms": &#123;</span><br><span class="line">                        "field": "category1",</span><br><span class="line">                        "size": 1000,</span><br><span class="line">                        "shard_size": 1000</span><br><span class="line">                    &#125;,</span><br><span class="line">                    "aggs": &#123;</span><br><span class="line">                        "amount": &#123;</span><br><span class="line">                            "sum": &#123;</span><br><span class="line">                                "field": "amount"</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        "category": &#123;</span><br><span class="line">                            "terms": &#123;</span><br><span class="line">                                "field": "category",</span><br><span class="line">                                "size": 1000,</span><br><span class="line">                                "shard_size": 1000</span><br><span class="line">                            &#125;,</span><br><span class="line">                            "aggs": &#123;</span><br><span class="line">                                "amount": &#123;</span><br><span class="line">                                    "sum": &#123;</span><br><span class="line">                                        "field": "amount"</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                "vendorMode": &#123;</span><br><span class="line">                                    "terms": &#123;</span><br><span class="line">                                        "field": "vendorMode",</span><br><span class="line">                                        "size": 1000,</span><br><span class="line">                                        "shard_size": 1000</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    "aggs": &#123;</span><br><span class="line">                                        "amount": &#123;</span><br><span class="line">                                            "sum": &#123;</span><br><span class="line">                                                "field": "amount"</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="优化成composite聚合"><a href="#优化成composite聚合" class="headerlink" title="优化成composite聚合"></a>优化成composite聚合</h1><p>多轮composite聚合，每次composite聚合需要遍历所有分⽚ ，并且遍历多次。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GETorder/_search?size=0&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "bool": &#123;</span><br><span class="line">            "must": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;</span><br><span class="line">                        <span class="attr">"term"</span>: &#123;</span><br><span class="line">                            <span class="attr">"gte"</span>: <span class="number">202111</span>,</span><br><span class="line">                            <span class="attr">"lte"</span>: <span class="number">202111</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs": &#123;</span><br><span class="line">        "statis": &#123;</span><br><span class="line">            "composite": &#123;</span><br><span class="line">                "sources": [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"term"</span>: &#123;</span><br><span class="line">                            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"term"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"category1"</span>: &#123;</span><br><span class="line">                            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"category1"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"category"</span>: &#123;</span><br><span class="line">                            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"category"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"vendorMode"</span>: &#123;</span><br><span class="line">                            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"vendorMode"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "amount": &#123;</span><br><span class="line">            "sum": &#123;</span><br><span class="line">                "field": "amount"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式系统</category>
        <category>搜索</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>composite聚合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java应用层实现MySQL读写分离</title>
    <url>/2022/07/02/java-impl-rw-separate/</url>
    <content><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>实现读写分离一般有4种机制：</p>
<ol>
<li>应用层实现（借助Spring的<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html" target="_blank" rel="noopener">AbstractRoutingDataSource</a>）。</li>
<li>框架层（如<a href="https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/" target="_blank" rel="noopener">sharding-jdbc</a>，<a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">tddl</a>）。 </li>
<li>中间件层（如<a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">mycat</a>）。</li>
<li>数据库/分布式存储本身支持，如分布式数据库或newSQL，如<a href="https://en.wikipedia.org/wiki/MySQL_Cluster" target="_blank" rel="noopener">MySQL Cluster</a>，<a href="https://www.oceanbase.com/" target="_blank" rel="noopener">OceanBase</a>，Redis Cluster等。</li>
</ol>
<p>本文主要分析应用层实现读写分离思路。读写分离实现思路：配置多个读写数据源，通过当前DAO层请求方法判断当前应该请求的数据源类型，如果是读方法，那么请求读库，如果是写方法，那么请求写库，如果一个方法既有读和写，那么写后读全部走写库，从而避免主从延迟带来数据一致问题。</p>
<p>应用层实现读写分离/垂直分库分表是简单的事情，但是应用层实现水平分库分表却是一个复杂问题，我曾经的项目是先遇到读写分离问题，于是自己应用层实现，然后遇到了分库分表问题，采用了sharding-jdbc的方案，该方案即解决了读写分离，也解决了分库分表。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="配置多数据源"><a href="#配置多数据源" class="headerlink" title="配置多数据源"></a>配置多数据源</h2><p>配置包含读写的数据源，主库命名<strong>ds-write</strong>，写库命名<strong>ds-read</strong>.</p>
<h2 id="判断当前读写方法"><a href="#判断当前读写方法" class="headerlink" title="判断当前读写方法"></a>判断当前读写方法</h2><p>通过Spring的AOP拦截DAO层请求方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAop</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.dao..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"changeDataSource()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//切换主库或者从库</span></span><br><span class="line">        DataSourceInterceptor.changeDataSource(joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"changeDataSource()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">(JoinPoint point)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法离开DAO层要清除当前数据源，但是不会清除使用过的是主还是从</span></span><br><span class="line">        DataSourceInterceptor.removeDataSource(point);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="切换主库的实现"><a href="#切换主库的实现" class="headerlink" title="切换主库的实现"></a>切换主库的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定只读的方法(人为指定，如selectXXX，findXXX，getXXX)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; READ_METHODS = Lists.newArrayList(<span class="string">"selectXXX"</span>);</span><br><span class="line">    <span class="comment">//标识当前线程是否使用过主库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Boolean&gt; masterFlag = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        String dataSource = <span class="string">"ds-write"</span>;</span><br><span class="line">        <span class="comment">//当前线程如果写过主库，那么后面的请求均走主库</span></span><br><span class="line">        String methodName = jp.getSignature().getName();</span><br><span class="line">        <span class="keyword">if</span> (!isMasterAccess() &amp;&amp; READ_METHODS.contains(methodName)) &#123;</span><br><span class="line">            dataSource = <span class="string">"ds-read"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setMasterFlag(<span class="keyword">true</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置最新的数据源</span></span><br><span class="line">        DataSourcetHolder.setDataSource(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMasterAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> masterFlag.get() == <span class="keyword">null</span> ? <span class="keyword">false</span> : masterFlag.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeDataSource</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        DataSourcetHolder.clearDataCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="设置最新的数据源"><a href="#设置最新的数据源" class="headerlink" title="设置最新的数据源"></a>设置最新的数据源</h2><p>设置最新的数据源到<strong>ThreadLocal</strong>里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于存储数据源的名字，以方便获取当前数据源进行切换。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourcetHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dsName)</span> </span>&#123;</span><br><span class="line">        holder.set(dsName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态数据源切换"><a href="#动态数据源切换" class="headerlink" title="动态数据源切换"></a>动态数据源切换</h2><p>动态数据源借助Spring的<strong>AbstractRoutingDataSource</strong>类来实现切换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取最新的数据源名字</span></span><br><span class="line">		<span class="keyword">return</span> DataSourcetHolder.currentDataSource();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="复制与延迟"><a href="#复制与延迟" class="headerlink" title="复制与延迟"></a>复制与延迟</h2><p>副本冗余的主从复制一定会带来数据一致性问题，由于不同系统的复制模型不同，所以不同系统保证的一致性级别不同。MySQL默认复制是异步复制，所以数据一致性问题是典型的最终一致性，一致性窗口时间没有确定性保证，而强制写后读走主库，属于会话Sticky，类似于一种会话一致性（非严格，因为读别人写不一定最新）或者读自己写一致性，但是在ShardingJDBC中，程序开始就设置HintManager.setMasterRouteOnly()，那么整个会话都走主库，所以保证会话一致性。由于MySQL异步复制由于采用从节点拉取主节点binlog，而不是主节点主动推送复制数据，所以从库会挂了而主库依旧不知道。我曾经在测试环境遇到从库挂了好几天的<a href="https://blog.51cto.com/thinklili/2591474" target="_blank" rel="noopener">情况</a>，主库依旧在工作。所以一致性几乎发生故障情况下不可保证。所以MySQL异步复制下，既有主库也有从库请求，一般是写后读全部查主库。但是如果MySQL配置的是全同步/半同步复制，那么数据一致性问题就会减弱，但是会导致严重性能问题。这是典型的PACELC的权衡。在没有发生网络分区或其他故障情况下，延迟和一致性的权衡。</p>
<p>复制会带来一致性问题，不同复制模型带来的一致性问题不同，而一致性问题通过和顺序存在关系。复制，一致性，顺序，共识存在深刻的联系。理解这些关系，对理解系统限制会有帮助。</p>
<h2 id="分库，分表，读写分离，水平垂直"><a href="#分库，分表，读写分离，水平垂直" class="headerlink" title="分库，分表，读写分离，水平垂直"></a>分库，分表，读写分离，水平垂直</h2><p>对于一个数据表的设计，需要考虑是否分库，是否分表，是否读写分离，水平还是垂直。而每种选择意味着不同的设计，总共有16种可能性。分库(Y/N) <strong>×</strong> 分表(Y/N) <strong>×</strong> 读写分离(Y/N) <strong>×</strong> 水平或垂直 = 16种。但是如果读写分离是必须的，那么其实有8种选择。而8种选择里面，垂直是较少的，所以大部分是水平的，其实就剩下了4种，实际需要根据不同情况进行选择。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>MySQL半同步复制（ <em><a href="https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html</a></em> ）</li>
<li>Jepsen一致性模型（ <em><a href="https://jepsen.io/consistency" target="_blank" rel="noopener">https://jepsen.io/consistency</a></em> ）</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
        <tag>应用设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka监控概览</title>
    <url>/2022/10/30/kafka-manager-explain/</url>
    <content><![CDATA[<h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><h2 id="kafka集群和broker"><a href="#kafka集群和broker" class="headerlink" title="kafka集群和broker"></a>kafka集群和broker</h2><h2 id="Borker"><a href="#Borker" class="headerlink" title="Borker"></a>Borker</h2><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="JMX-type-producer-metrics"><a href="#JMX-type-producer-metrics" class="headerlink" title="JMX type=producer-metrics"></a>JMX type=producer-metrics</h3><p>record-error-rate</p>
<p>record-retry-rate</p>
<p>request-latency-avg</p>
<p>outgoing-byte-rate</p>
<p>record-send-rate</p>
<p>request-rate</p>
<p>request-size-avg</p>
<p>batch-size-avg</p>
<p>record-size-avg</p>
<p>records-per-request-avg</p>
<p>record-queue-time-avg</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="JMX-type-consumer-fetch-manager-metrics"><a href="#JMX-type-consumer-fetch-manager-metrics" class="headerlink" title="JMX type=consumer-fetch-manager-metrics"></a>JMX type=consumer-fetch-manager-metrics</h3><p>fetch-latency-avg</p>
<p>records-lag-max</p>
<p>bytes-consumed-rate</p>
<p>records-consumed-rate</p>
<p>fetch-rate</p>
<p>fetch-size-avg</p>
<p>records-per-request-avg</p>
<h3 id="JMX-type-consumer-coordinator-metrics"><a href="#JMX-type-consumer-coordinator-metrics" class="headerlink" title="JMX type=consumer-coordinator-metrics"></a>JMX type=consumer-coordinator-metrics</h3><p>sync-time-avg</p>
<p>sync-rate</p>
<p>commit-latency-avg</p>
<p>assigned-partitions</p>
]]></content>
  </entry>
  <entry>
    <title>elasticsearch(4) - 常用Composite聚合查询</title>
    <url>/2021/08/30/elasticsearch-series4-aggregation-search/</url>
    <content><![CDATA[<p>es常见的聚合查询有composite，现在案例主要是composite聚合例子。</p>
<h1 id="Bool和Nested查询（订单结算查询）"><a href="#Bool和Nested查询（订单结算查询）" class="headerlink" title="Bool和Nested查询（订单结算查询）"></a>Bool和Nested查询（订单结算查询）</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"1"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"nested"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"sharer"</span>,</span><br><span class="line">            <span class="attr">"query"</span>: &#123;</span><br><span class="line">              <span class="attr">"term"</span>: &#123;</span><br><span class="line">                <span class="attr">"sharer.sharerId"</span>: &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="string">"24"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">201103</span>,</span><br><span class="line">              <span class="attr">"lte"</span>: <span class="number">202202</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"categoryId"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"1"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"payMonth"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">201103</span>,</span><br><span class="line">              <span class="attr">"lte"</span>: <span class="number">202202</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"orderId"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"term"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Composite聚合和嵌套聚合（费用统计）"><a href="#Composite聚合和嵌套聚合（费用统计）" class="headerlink" title="Composite聚合和嵌套聚合（费用统计）"></a>Composite聚合和嵌套聚合（费用统计）</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /order/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: [</span><br><span class="line">              <span class="string">"16861"</span>,</span><br><span class="line">              <span class="string">"25590"</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"sharerTerm"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"202003"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"compositeData"</span>: &#123;</span><br><span class="line">      <span class="attr">"composite"</span>: &#123;</span><br><span class="line">        <span class="attr">"sources"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"sharerId"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"sharerId"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"beginTerm"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"sharerTerm"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"courseId"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"amortizesNest"</span>: &#123;</span><br><span class="line">          <span class="attr">"nested"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"sharerAmortizes"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"amortizes.term"</span>: &#123;</span><br><span class="line">              <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"term"</span>: &#123;</span><br><span class="line">                  <span class="attr">"sharerAmortizes.term"</span>: <span class="number">202002</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"amortizes.amount"</span>: &#123;</span><br><span class="line">                  <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                    <span class="attr">"field"</span>: <span class="string">"sharerAmortizes.amount"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Compsite聚合和Sum统计（支付摊期统计）"><a href="#Compsite聚合和Sum统计（支付摊期统计）" class="headerlink" title="Compsite聚合和Sum统计（支付摊期统计）"></a>Compsite聚合和Sum统计（支付摊期统计）</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /order/_search?size=0&amp;request_cache=true</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"payMonth"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">202110</span>,</span><br><span class="line">              <span class="attr">"lte"</span>: <span class="number">202110</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">202110</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"110872"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"buckets"</span>: &#123;</span><br><span class="line">      <span class="attr">"composite"</span>: &#123;</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">"sources"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"courseId"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"term"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"earningSum"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"earningSum"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.1"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.1"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.2"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.2"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.3"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.3"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.4"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.4"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.5"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.5"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"courseEarning"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"courseEarning"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"cost"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"cost"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"selfCost"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"selfCost"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"allCost"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"allCost"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"deliveryTaxedFee"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"deliveryTaxedFee"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"deliveryFee"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"deliveryFee"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"sharerSettles"</span>: &#123;</span><br><span class="line">          <span class="attr">"nested"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"sharerSettles"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"sharerSettles.sharerId"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"sharerSettles.sharerId"</span>,</span><br><span class="line">                <span class="attr">"size"</span>: <span class="number">1000</span>,</span><br><span class="line">                <span class="attr">"shard_size"</span>: <span class="number">1000</span>,</span><br><span class="line">                <span class="attr">"collect_mode"</span>: <span class="string">"breadth_first"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"sharerSettles.rate"</span>: &#123;</span><br><span class="line">                  <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                    <span class="attr">"field"</span>: <span class="string">"sharerSettles.rate_key"</span>,</span><br><span class="line">                    <span class="attr">"size"</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="attr">"shard_size"</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="attr">"collect_mode"</span>: <span class="string">"breadth_first"</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                    <span class="attr">"sharerSettles.shareSum"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.shareSum"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.share"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.share"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.cost"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.cost"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.shareCost"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.shareCost"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.taxedEarning"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.taxedEarning"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.earning"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.earning"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"sharerSettles.rate"</span>: &#123;</span><br><span class="line">                      <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"sharerSettles.rate"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Composite聚合（支付方式统计）"><a href="#Composite聚合（支付方式统计）" class="headerlink" title="Composite聚合（支付方式统计）"></a>Composite聚合（支付方式统计）</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /order/_search?size=0&amp;request_cache=true</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"payMonth"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">202010</span>,</span><br><span class="line">              <span class="attr">"lte"</span>: <span class="number">202011</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"gte"</span>: <span class="number">202010</span>,</span><br><span class="line">              <span class="attr">"lte"</span>: <span class="number">202011</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"buckets"</span>: &#123;</span><br><span class="line">      <span class="attr">"composite"</span>: &#123;</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">"sources"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"courseId"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"courseId"</span>,</span><br><span class="line">                <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"term"</span>,</span><br><span class="line">                <span class="attr">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"payFrom"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"payFrom"</span>,</span><br><span class="line">                <span class="attr">"missing_bucket"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"courseEarning"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"courseEarning"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.1"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.1"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.2"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.2"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.3"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.3"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.4"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.4"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"goodsEarning.5"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"goodsEarning.5"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"poundage"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"poundage"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"agentFee"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"agentFee"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"deliveryTaxedFee"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"deliveryTaxedFee"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"deliveryFee"</span>: &#123;</span><br><span class="line">          <span class="attr">"sum"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"deliveryFee"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式系统</category>
        <category>搜索</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>聚合查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类库封装的三步</title>
    <url>/2023/07/09/java-library-encapsulation/</url>
    <content><![CDATA[<p>我觉得最重要的要有<strong>一致性</strong>的理念，也就是灵魂。当然也可以在实现完之后提炼一个理念。</p>
<p>总共分为三步：1. 提炼出一个设计理念 2. 设计实现  3.测试</p>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>比如有：使用简单，配置灵活，扩展性好，测试完备，具备内部监控。</p>
<h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><h2 id="1-通用实现的结构"><a href="#1-通用实现的结构" class="headerlink" title="1.通用实现的结构"></a>1.通用实现的结构</h2><p>需要给业务层提供通用类库，该以怎么样的方式提供？通常有以下几种方式：</p>
<ol>
<li>类似于apache common，JDK这种模式，应用层调用库。</li>
<li>类似于IOC/框架模式/模板(XXXTemplate)/策略(回调)模式，框架调用应用层代码。典型的如JDBCTemplate或SPI模式。</li>
<li>类似于普通Spring模式，提供库，并且暴露配置且提供默认配置，由应用层自定义设置，业务层直接使用。</li>
<li>类似于Spring boot stater+auto-configuration这种模式。</li>
</ol>
<h2 id="2-通过JMX暴露操作和属性"><a href="#2-通过JMX暴露操作和属性" class="headerlink" title="2.通过JMX暴露操作和属性"></a>2.通过JMX暴露操作和属性</h2><p>使用Spring的@ManagedResource或者注册到MBeanServer中。</p>
<p>或者纯JDK的注册到MBeanServer。</p>
<h2 id="3-通过自定义Spring-Boot-Actuator-endpoint和InfoContributor监控和交互"><a href="#3-通过自定义Spring-Boot-Actuator-endpoint和InfoContributor监控和交互" class="headerlink" title="3.通过自定义Spring Boot Actuator endpoint和InfoContributor监控和交互"></a>3.通过自定义Spring Boot Actuator endpoint和InfoContributor监控和交互</h2><ol>
<li>通过Springboot Actuator  <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/info/InfoContributor.html" target="_blank" rel="noopener">InfoContributor</a> 接口来暴露endpoint info信息。</li>
<li>通过自定义的Endpoint来内部信息。</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>没有测试的类库质量会较低。</p>
]]></content>
      <categories>
        <category>Java类库设计</category>
      </categories>
      <tags>
        <tag>组件设计</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>项目，Kafka消费组和Topic关系</title>
    <url>/2022/09/12/kafka-project-consumer-group/</url>
    <content><![CDATA[<p>这里的项目可以认为是一个微服务。需要根据场景选择<strong>项目</strong>，<strong>消费组</strong>，<strong>topic</strong>关系。</p>
<ol>
<li>一个项目下：多个消费组对应一个topic。（n：1）  教务美育结算</li>
<li>一个项目下，多个消费组对应多个topic。（1:1）    暂无？？？</li>
<li>一个项目下，一个消费组对应多个topic。(1 : n)     教务订单，智学用户</li>
<li>一个项目下，一个消费组对应一个topic。(1：1)     最简单情况 ，比如换课，退款</li>
<li>多个项目下，多个消费组对应一个topic。（n：1）  智学用户清除</li>
</ol>
<p><strong>问题在于2,3的区别是什么？ 3可以通过group(项目名字)找到所有的topic，方便查找，并且也不可能每起一个项目就开一堆消费组。看着是更省资源的方式。</strong></p>
<p>简化这个问题：一个项目，要消费很多topic，选择多个group好还是一个group好呢？区别是啥?</p>
<p>所以选择的维度是：<strong>项目+消费组+topic</strong>，这里可以看到没有了消费者的选择。</p>
]]></content>
      <categories>
        <category>消息中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka系列1-设计与实现</title>
    <url>/2022/01/08/kafka-series1-design-and-implementation/</url>
    <content><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="不要害怕文件系统！"><a href="#不要害怕文件系统！" class="headerlink" title="不要害怕文件系统！"></a>不要害怕文件系统！</h3><h3 id="常量时间足够了"><a href="#常量时间足够了" class="headerlink" title="常量时间足够了"></a>常量时间足够了</h3><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="端到端批量压缩"><a href="#端到端批量压缩" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h3><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="推VS拉"><a href="#推VS拉" class="headerlink" title="推VS拉"></a>推VS拉</h3><h3 id="消费者位置"><a href="#消费者位置" class="headerlink" title="消费者位置"></a>消费者位置</h3><h3 id="离线数据加载"><a href="#离线数据加载" class="headerlink" title="离线数据加载"></a>离线数据加载</h3><h3 id="静态成员关系"><a href="#静态成员关系" class="headerlink" title="静态成员关系"></a>静态成员关系</h3><h2 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h2><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="复制日志：Quorums-ISRs-State-Machines-天啊"><a href="#复制日志：Quorums-ISRs-State-Machines-天啊" class="headerlink" title="复制日志：Quorums,ISRs,State Machines(天啊)"></a>复制日志：Quorums,ISRs,State Machines(天啊)</h3><h3 id="未完成的领导选举：如果他们全部挂了呢？"><a href="#未完成的领导选举：如果他们全部挂了呢？" class="headerlink" title="未完成的领导选举：如果他们全部挂了呢？"></a>未完成的领导选举：如果他们全部挂了呢？</h3><h3 id="可用性和持久化保证"><a href="#可用性和持久化保证" class="headerlink" title="可用性和持久化保证"></a>可用性和持久化保证</h3><h3 id="复制管理"><a href="#复制管理" class="headerlink" title="复制管理"></a>复制管理</h3><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><h3 id="日志压缩基础"><a href="#日志压缩基础" class="headerlink" title="日志压缩基础"></a>日志压缩基础</h3><h3 id="日志压缩提供了什么样的保证？"><a href="#日志压缩提供了什么样的保证？" class="headerlink" title="日志压缩提供了什么样的保证？"></a>日志压缩提供了什么样的保证？</h3><h3 id="日志压缩细节"><a href="#日志压缩细节" class="headerlink" title="日志压缩细节"></a>日志压缩细节</h3><h3 id="配置日志清理器"><a href="#配置日志清理器" class="headerlink" title="配置日志清理器"></a>配置日志清理器</h3><h2 id="配额"><a href="#配额" class="headerlink" title="配额"></a>配额</h2><h3 id="为什么配额是必须的？"><a href="#为什么配额是必须的？" class="headerlink" title="为什么配额是必须的？"></a>为什么配额是必须的？</h3><h3 id="客户端组"><a href="#客户端组" class="headerlink" title="客户端组"></a>客户端组</h3><h3 id="配额配置"><a href="#配额配置" class="headerlink" title="配额配置"></a>配额配置</h3><h3 id="网络带宽的配额"><a href="#网络带宽的配额" class="headerlink" title="网络带宽的配额"></a>网络带宽的配额</h3><h3 id="请求速率的带宽"><a href="#请求速率的带宽" class="headerlink" title="请求速率的带宽"></a>请求速率的带宽</h3><h3 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h3><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><h3 id="批记录"><a href="#批记录" class="headerlink" title="批记录"></a>批记录</h3><h4 id="控制批次"><a href="#控制批次" class="headerlink" title="控制批次"></a>控制批次</h4><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h4><h3 id="旧版消息格式"><a href="#旧版消息格式" class="headerlink" title="旧版消息格式"></a>旧版消息格式</h3><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h3 id="保证性"><a href="#保证性" class="headerlink" title="保证性"></a>保证性</h3><h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><h3 id="消费者偏移追踪"><a href="#消费者偏移追踪" class="headerlink" title="消费者偏移追踪"></a>消费者偏移追踪</h3><h3 id="Zookeeper目录"><a href="#Zookeeper目录" class="headerlink" title="Zookeeper目录"></a>Zookeeper目录</h3><h3 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h3><h3 id="Broker节点注册"><a href="#Broker节点注册" class="headerlink" title="Broker节点注册"></a>Broker节点注册</h3><h3 id="Broker主题注册"><a href="#Broker主题注册" class="headerlink" title="Broker主题注册"></a>Broker主题注册</h3><h3 id="集群ID"><a href="#集群ID" class="headerlink" title="集群ID"></a>集群ID</h3><h3 id="Broker节点注册-1"><a href="#Broker节点注册-1" class="headerlink" title="Broker节点注册"></a>Broker节点注册</h3>]]></content>
      <categories>
        <category>消息中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>向量检索Faiss实战</title>
    <url>/2024/01/07/faiss-practice/</url>
    <content><![CDATA[<h1 id="faiss简介"><a href="#faiss简介" class="headerlink" title="faiss简介"></a>faiss简介</h1><p><code>Faiss is a library for efficient similarity search and clustering of dense vectors。</code></p>
<p>官方介绍: Faiss是一个用于高效相似性搜索和密集向量聚类的库。也就是用来实现高效的向量检索。</p>
<p>Faiss主要组件包括：</p>
<ol>
<li>索引结构：<strong>Flat</strong>（暴力搜索) 、<strong>IVF</strong>(Inverted File)、<strong>IVFPQ</strong>(Inverted File with Product Quantization)、<strong>HNSW</strong>(Hierarchical Navigable Small World)，索引结构可以加速相似性搜索，降低查询时间。</li>
<li>向量编码：<strong>PQ</strong>(Product Quantization)、<strong>OPQ</strong>(Optimized Product Quantization)。编码可以将高维向量映射到低维空间中，同时保持距离的相似性，有助于减少内存占用和计算量。</li>
<li>相似性度量：欧氏距离、内积、Jaccard 相似度等。</li>
</ol>
<p>Faiss的核心API有：</p>
<ol>
<li><p><strong>IndexFactory(d int, description string, metric int)</strong>：用来创建索引，通过维度，索引方法描述，相似性度量来创建索引。</p>
</li>
<li><p><strong>Ntotal()</strong> 索引向量的数量。</p>
</li>
<li><p><strong>Train(x []float32)</strong>  用一组具有代表性的向量训练索引。</p>
</li>
<li><p><strong>Add(x []float32)</strong>，用于创建向量检索集。</p>
</li>
<li><p><strong>Search(x []float32, k int64) (distances []float32, labels []int64, err error)</strong>，x向量在k紧邻进行检索，返回每个查询向量的 k 个最近邻的 ID 以及相应的距离。</p>
</li>
</ol>
<p>如何理解<strong>Add</strong>和<strong>Search</strong>方法呢？<strong>Add</strong>是添加向量，<strong>Search</strong>从向量中检索。比如一篇文章拆分成5个片段，此时调用Add方法生成了5个向量，查询的内容会生成一个查询向量，那么<strong>Search</strong>中<strong>k=2</strong>会返回最近的两个近邻，也就是返回5个向量中的2个向量，那么返回值<strong>distances</strong>是查询向量到返回<strong>2</strong>个向量的距离，返回值<strong>labels</strong>是返回的向量在5个片段中的位置，此时就可以知道返回了那些段。</p>
<p>Faiss的主要流程是：</p>
<ol>
<li>初始化索引结构，指定相似性度量方法(metric)和编码方法(description)。使用<strong>IndexFactory</strong>。</li>
<li>将原始向量数据添加到索引中。使用<strong>Add</strong>。</li>
<li>对查询向量进行编码，并在索引中搜索与查询向量相似的向量。使用<strong>Search</strong>。</li>
<li>获取搜索结果，并根据需要进行后处理。</li>
</ol>
<h1 id="文档向量化检索设计"><a href="#文档向量化检索设计" class="headerlink" title="文档向量化检索设计"></a>文档向量化检索设计</h1><p>如果我们要实现一篇文档的向量化检索该如何设计呢？可以使用mysql和内存缓存作为文档的向量存储，方案可以先将<strong>文档拆分</strong>，然后存储到数据库中，表设计如下：</p>
<p>mysql存储拆分后的文档—— primary_id，edoc_part_content，project_id，embedding</p>
<p>内存缓存存储向量位置到文档主键ID——键：project_id+Ntotal()   值：primary_id</p>
<p>服务启动初始化时候从mysql加载doc表，获取到所有的文档，然后通过Add方法加载到检索集中，每加一次，调用<strong>Ntotal</strong>方法获取当前向量总数，也就是当前向量数组的位置下标，存入内存缓存中，</p>
<p>查询时候，生成查询向量后，调用<strong>Search</strong>方法，获取到检索集位置，然后获取从内存缓存中获取mysql中的主键id，去mysql查询到文档的内容。</p>
<h1 id="Faiss配置指南"><a href="#Faiss配置指南" class="headerlink" title="Faiss配置指南"></a>Faiss配置指南</h1><h2 id="相似性计算方法"><a href="#相似性计算方法" class="headerlink" title="相似性计算方法"></a>相似性计算方法</h2><p>相似性计算主要有余弦，L1，L2等计算方法。</p>
<p><code>InnerProduct</code>内积/余弦相似度</p>
<p><code>L1</code> <a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hy592070616/article/details/121569933%3Fspm%3D1001.2014.3001.5501">曼哈顿距离</a></p>
<p><code>L2</code>    欧氏距离</p>
<p><code>Linf</code> 无穷范数</p>
<p><code>Lp</code>    p范数</p>
<p><code>Canberra</code>    <a href="https://zhuanlan.zhihu.com/p/440130486?utm_id=0" target="_blank" rel="noopener">BC相异度</a></p>
<p><code>BrayCurtis</code>  <a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hy592070616/article/details/122271656">兰氏距离/堪培拉距离</a></p>
<p><code>JensenShannon</code>  <a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hy592070616/article/details/122387046%3Fspm%3D1001.2014.3001.5501">JS散度</a></p>
<h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引描述主要是向量检索算法。主要有以下几个：</p>
<p>Flat：最基础的索引结构，比较精确</p>
<p>IVF：Inverted File 倒排文件</p>
<p>PQ：Product Quantization 乘积量化</p>
<p>PCA：Principal Component Analysis 主成分分析</p>
<p>HNSW：Hierarchical Navigable Small World  分层的可导航小世界</p>
<table>
<thead>
<tr>
<th align="left"><strong>相似性计算方法</strong></th>
<th align="left"><strong>索引描述</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">InnerProduct</td>
<td align="left">Flat</td>
<td align="left">余弦相似度 暴力检索</td>
</tr>
<tr>
<td align="left">InnerProduct</td>
<td align="left">IVF100,Flat</td>
<td align="left">余弦相似度   k-means聚类中心为100倒排（IVFx）暴力检索</td>
</tr>
<tr>
<td align="left">L2</td>
<td align="left">Flat</td>
<td align="left">欧式距离 暴力检索</td>
</tr>
<tr>
<td align="left">InnerProduct</td>
<td align="left">PQ16</td>
<td align="left"><strong>余弦相似度 乘积量化</strong> 利用乘积量化的方法，改进了普通检索，将一个向量的维度切成x段，每段分别进行检索，每段向量的检索结果取交集后得出最后的TopK。因此速度很快，而且占用内存较小，召回率也相对较高</td>
</tr>
<tr>
<td align="left">L2</td>
<td align="left">PCA32,IVF100,PQ16</td>
<td align="left">欧式距离 将向量先降维成32维，再用IVF100 PQ16的方法构建索引</td>
</tr>
<tr>
<td align="left">L2</td>
<td align="left">PCA32,HNSW32</td>
<td align="left">欧式距离 处理HNSW内存占用过大的问题</td>
</tr>
<tr>
<td align="left">L2</td>
<td align="left"><code>IVF100,PQ16</code></td>
<td align="left">欧式距离 <strong>倒排乘积量化</strong>：工业界大量使用此方法，各项指标都均可以接受，利用乘积量化的方法，改进了IVF的k-means，将一个向量的维度切成x段，每段分别进行k-means再检索</td>
</tr>
<tr>
<td align="left">其他</td>
<td align="left">其他</td>
<td align="left">大家自己枚举调优吧，采用下文测试方法测试是否成功</td>
</tr>
</tbody></table>
<h1 id="GoLang代码例子"><a href="#GoLang代码例子" class="headerlink" title="GoLang代码例子"></a>GoLang代码例子</h1><p><strong>faiss</strong>本身用<strong>C++</strong>实现，这里使用<strong>go-faiss</strong>来实现例子，<strong>embeding</strong>获取通过<strong>openai</strong>的接口实现。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> services</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line"></span><br><span class="line">	gofaiss <span class="string">"github.com/DataIntelligenceCrew/go-faiss"</span></span><br><span class="line">	<span class="string">"github.com/sashabaranov/go-openai"</span></span><br><span class="line">	<span class="string">"github.com/spf13/cast"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AuthToken = <span class="string">"openai的token"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MetricTypeMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"InnerProduct"</span>:  gofaiss.MetricInnerProduct,  <span class="comment">// 0</span></span><br><span class="line">	<span class="string">"L2"</span>:            gofaiss.MetricL2,            <span class="comment">// 1</span></span><br><span class="line">	<span class="string">"L1"</span>:            gofaiss.MetricL1,            <span class="comment">// 2</span></span><br><span class="line">	<span class="string">"Linf"</span>:          gofaiss.MetricLinf,          <span class="comment">// 3</span></span><br><span class="line">	<span class="string">"Lp"</span>:            gofaiss.MetricLp,            <span class="comment">// 4</span></span><br><span class="line">	<span class="string">"Canberra"</span>:      gofaiss.MetricCanberra,      <span class="comment">// 20</span></span><br><span class="line">	<span class="string">"BrayCurtis"</span>:    gofaiss.MetricBrayCurtis,    <span class="comment">// 21</span></span><br><span class="line">	<span class="string">"JensenShannon"</span>: gofaiss.MetricJensenShannon, <span class="comment">// 22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FaissReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsDemo      <span class="keyword">bool</span>      <span class="string">`json:"is_demo"`</span></span><br><span class="line">	DBSize      <span class="keyword">int</span>       <span class="string">`json:"db_size"`</span></span><br><span class="line">	QuerySize   <span class="keyword">int</span>       <span class="string">`json:"query_size"`</span></span><br><span class="line">	KNearest    <span class="keyword">int64</span>     <span class="string">`json:"k_nearest"`</span></span><br><span class="line">	Question    <span class="keyword">string</span>    <span class="string">`json:"question"`</span></span><br><span class="line">	Model       <span class="keyword">string</span>    <span class="string">`json:"model"`</span></span><br><span class="line">	Embedding   []<span class="keyword">float32</span> <span class="string">`json:"embedding"`</span></span><br><span class="line">	Dimension   <span class="keyword">int</span>       <span class="string">`json:"dimension"`</span>   <span class="comment">// 维度</span></span><br><span class="line">	Description <span class="keyword">string</span>    <span class="string">`json:"description"`</span> <span class="comment">// 索引描述</span></span><br><span class="line">	Metric      <span class="keyword">string</span>    <span class="string">`json:"metric"`</span>      <span class="comment">// 相似性度量方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FaissRsp <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsTrained <span class="keyword">bool</span>  <span class="string">`json:"is_trained"`</span></span><br><span class="line">	Ntotal    <span class="keyword">int64</span> <span class="string">`json:"n_total"`</span></span><br><span class="line">	Dimension <span class="keyword">int</span>   <span class="string">`json:"dimension"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmbeddingReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Prompt <span class="keyword">string</span> <span class="string">`json:"prompt"`</span></span><br><span class="line">	Model  <span class="keyword">string</span> <span class="string">`json:"model"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmbeddingRsp <span class="keyword">struct</span> &#123;</span><br><span class="line">	Embedding []<span class="keyword">float32</span> <span class="string">`json:"embedding"`</span></span><br><span class="line">	Time      <span class="keyword">string</span>    <span class="string">`json:"time"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryFaiss</span><span class="params">(req FaissReq)</span> <span class="params">(rsp FaissRsp, err error)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"all metrics is:%+v"</span>, MetricTypeMap)</span><br><span class="line">	<span class="keyword">if</span> req.IsDemo &#123;</span><br><span class="line">		d := req.Dimension  <span class="comment">// 向量维度</span></span><br><span class="line">		nb := req.DBSize    <span class="comment">// 全部数据大小</span></span><br><span class="line">		nq := req.QuerySize <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据的向量</span></span><br><span class="line">		xb := <span class="built_in">make</span>([]<span class="keyword">float32</span>, d*nb)</span><br><span class="line">		<span class="comment">// 查询数据的向量</span></span><br><span class="line">    xq := <span class="built_in">make</span>([]<span class="keyword">float32</span>, d*nq)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nb; i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; d; j++ &#123;</span><br><span class="line">				xb[i*d+j] = rand.Float32()</span><br><span class="line">			&#125;</span><br><span class="line">			xb[i*d] += <span class="keyword">float32</span>(i) / <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化查询数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nq; i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; d; j++ &#123;</span><br><span class="line">				xq[i*d+j] = rand.Float32()</span><br><span class="line">			&#125;</span><br><span class="line">			xq[i*d] += <span class="keyword">float32</span>(i) / <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Faiss</span></span><br><span class="line">		indexImpl, err := gofaiss.IndexFactory(d, req.Description, MetricTypeMap[req.Metric])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"IndexFactory err:%+v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> indexImpl.Delete()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练全部数据</span></span><br><span class="line">		trainErr := indexImpl.Train(xb)</span><br><span class="line">		<span class="keyword">if</span> trainErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"Train err:%+v"</span>, trainErr)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 将全部数据加入Faiss中</span></span><br><span class="line">		addErr := indexImpl.Add(xb)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"addErr err:%+v"</span>, addErr)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		k := <span class="keyword">int64</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合法性检查，用全部数据的前5*维度个</span></span><br><span class="line">		dist, ids, err := indexImpl.Search(xb[:<span class="number">5</span>*d], k)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"Search err:%+v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"Search dist:%+v,ids:%+v"</span>, dist, ids)</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"ids="</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">int64</span>(<span class="number">0</span>); j &lt; k; j++ &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"%5d "</span>, ids[i*k+j])</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"dist="</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">int64</span>(<span class="number">0</span>); j &lt; k; j++ &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"%7.6g "</span>, dist[i*k+j])</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过查询数据xq进行向量检索</span></span><br><span class="line">		ps, err := gofaiss.NewParameterSpace()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"NewParameterSpace err:%+v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> ps.Delete()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := ps.SetIndexParameter(indexImpl, <span class="string">"nprobe"</span>, <span class="number">10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"SetIndexParameter err:%+v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_, ids, err = indexImpl.Search(xq, k)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">" indexImpl.Search Last err:%+v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"ids (last 5 results)="</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">int64</span>(nq) - <span class="number">5</span>; i &lt; <span class="keyword">int64</span>(nq); i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">int64</span>(<span class="number">0</span>); j &lt; k; j++ &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"%5d "</span>, ids[i*k+j])</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> FaissRsp&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	indexImpl, err := gofaiss.IndexFactory(req.Dimension, req.Description, MetricTypeMap[req.Metric])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"IndexFactory error:%+v,req:%+v"</span>, err, req)</span><br><span class="line">		<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> embeddingArray []<span class="keyword">float32</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.Question) != <span class="number">0</span> &#123;</span><br><span class="line">		embedding, embeddingErr := Embedding(context.Background(), EmbeddingReq&#123;Prompt: req.Question, Model: req.Model&#125;)</span><br><span class="line">		<span class="keyword">if</span> embeddingErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"Embedding err:%+v"</span>, embeddingErr)</span><br><span class="line">			<span class="keyword">return</span> FaissRsp&#123;&#125;, embeddingErr</span><br><span class="line">		&#125;</span><br><span class="line">		embeddingArray = embedding.Embedding</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		embeddingArray = req.Embedding</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"embedding is:%s"</span>, jsonString(embeddingArray))</span><br><span class="line"></span><br><span class="line">	err = indexImpl.Train(embeddingArray)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"indexImpl.Train error:%+v,req:%+v"</span>, err, req)</span><br><span class="line">		<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	err = indexImpl.Add(embeddingArray)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"indexImpl.Add error:%+v,req:%+v"</span>, err, req)</span><br><span class="line">		<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dist, ids, err := indexImpl.Search(embeddingArray, req.KNearest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"Search err:%+v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> FaissRsp&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"Search dist:%s,\n ids:%s"</span>, jsonString(dist), jsonInt64String(ids))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FaissRsp&#123;IsTrained: indexImpl.IsTrained(), Ntotal: indexImpl.Ntotal(), Dimension: indexImpl.D()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonString</span><span class="params">(data []<span class="keyword">float32</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	marshal, _ := json.Marshal(data)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(marshal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonInt64String</span><span class="params">(data []<span class="keyword">int64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	marshal, _ := json.Marshal(data)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(marshal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Embedding 根据openai获取embedding</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Embedding</span><span class="params">(ctx context.Context, req EmbeddingReq)</span> <span class="params">(rsp EmbeddingRsp, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> model openai.EmbeddingModel</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.Model) == <span class="number">0</span> &#123;</span><br><span class="line">		model = openai.AdaEmbeddingV2</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		model = openai.EmbeddingModel(cast.ToInt(req.Model))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cfg := openai.DefaultConfig(AuthToken)</span><br><span class="line">	cfg.BaseURL = <span class="string">"https://api.aiproxy.io/v1"</span></span><br><span class="line">	client := openai.NewClientWithConfig(cfg)</span><br><span class="line">	resp, err := client.CreateEmbeddings(ctx, openai.EmbeddingRequest&#123;</span><br><span class="line">		Input: req.Prompt,</span><br><span class="line">		Model: model,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"Embedding error: %v,question:%s,model:%s,resp:%+v"</span>, err, req.Prompt, model)</span><br><span class="line">		<span class="keyword">return</span> rsp, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(resp.Data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> EmbeddingRsp&#123;</span><br><span class="line">			Embedding: resp.Data[<span class="number">0</span>].Embedding,</span><br><span class="line">			Time:      <span class="string">""</span>,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rsp, errors.New(<span class="string">"没有Embeddings"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/facebookresearch/faiss" target="_blank" rel="noopener">https://github.com/facebookresearch/faiss</a></p>
<p><a href="https://github.com/DataIntelligenceCrew/go-faiss" target="_blank" rel="noopener">https://github.com/DataIntelligenceCrew/go-faiss</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/357414033" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357414033</a></p>
<p><a href="https://guangzhengli.com/blog/zh/vector-database/" target="_blank" rel="noopener">https://guangzhengli.com/blog/zh/vector-database/</a></p>
<p><a href="https://faiss.ai/index.html" target="_blank" rel="noopener">https://faiss.ai/index.html</a></p>
<p><a href="https://github.com/sashabaranov/go-openai/blob/master/embeddings.go" target="_blank" rel="noopener">https://github.com/sashabaranov/go-openai/blob/master/embeddings.go</a></p>
<p><a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="noopener">https://platform.openai.com/docs/guides/embeddings</a></p>
<p><a href="https://openai.com/blog/new-and-improved-embedding-model" target="_blank" rel="noopener">https://openai.com/blog/new-and-improved-embedding-model</a></p>
]]></content>
      <categories>
        <category>llm</category>
      </categories>
      <tags>
        <tag>facebook faiss</tag>
        <tag>openai</tag>
        <tag>embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计的启发60条黄金法则</title>
    <url>/2020/09/01/ood-heuristics-translate/</url>
    <content><![CDATA[<p>本文翻译内容来自<a href="http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf" target="_blank" rel="noopener">http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf</a> ，主要是面向对象设计的启发。而这些checklist来自Arthur J. Riel的书Object-Oriented Design Heuristics总结的checklist,中文出版书叫面向对象启示录,非常棒的一本书。中文也有相关checklist的翻译，<a href="https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html" target="_blank" rel="noopener">https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html</a> ，但是我没有参考这个，结合了自己的理解尽可能客观的翻译原文。虽然有些地方很生硬，但是作为提高设计水平也值得尝试。</p>
<ol>
<li>不要重复自己！不要重复自己！不要重复自己！（我已经重复了）</li>
<li>所有数据应该隐藏在类内。</li>
<li>类的使用者必须依赖于公共接口，但是类不应该依赖于使用它的客户端。</li>
<li>最小化类的消息规范。</li>
<li>实现所有客户端可理解的最小接口。</li>
<li>不要在一个类的公共接口展现实现细节，比如支持的功能。</li>
<li>不要将用户不需要的或者不感兴趣特性的聚集在公共接口。</li>
<li>一个类应该捕获有且只有一个关键抽象。</li>
<li>保存数据和行为在同一地方。</li>
<li>拆分不相关信息到另一个类。</li>
<li>不要向对象请求它的状态，或者显示设置状态。向对象请求为你做事。</li>
<li>将对象视为一类服务而不是一类数据。</li>
<li>设计面向对象服务时使用它们的状态决定行为。</li>
<li>使用不可变对象，也叫信使。</li>
<li>设计时，尽可能水平得，统一得分配系统智能。</li>
<li>系统中不要创建上帝对象，对那些名字包含Driver, Manager, System, or Subsystem的类保持怀疑。</li>
<li>小心那些在公共接口中有很多访问器方法的类，拥有这些意味着相关数据和行为没有保持在一处。</li>
<li>todo</li>
<li>尽可能对真实世界建模。</li>
<li>从设计中消除不相关的类</li>
<li>减少系统无关的类。</li>
<li>todo</li>
<li>最小化类和其他类的协作者。</li>
<li>最小化类和协作者之间的消息传递。（这是一种叫动态解耦的解耦形式）</li>
<li>最小化类和协作者之间的协作数量，比如不同的消息传递。</li>
<li>如果一个类包含另一个类的对象，包含类应该传递消息给被包含对象，包含关系应始终暗示使用关系。</li>
<li>在一个类内定义的大多数方法大多数情况下应该使用数据成员变量。当这个启发被打破时候意味着差的内聚性。</li>
<li>类不应该包含  开发者能够短期记忆记住的类的实例变量，这个数字一般是6.</li>
<li>一个类必须知道它包含什么，但是永远不应该知道谁包含它。</li>
<li>继承应该只被用作对层次体系建模。</li>
<li>派生类必须根据定义了解其基类，但基类不应知道任何关于它们的派生类的信息。</li>
<li>所以数据在基类中应该私有，不要使用受保护的数据，指定受保护查询当希望数据隐藏其表现。</li>
<li>理论上，继承层次应该很深，越深越好。</li>
<li>todo</li>
<li>对于实现继承结构，所有抽象类必须是基类。</li>
<li>在实现继承时，所有基类应该是抽象类。</li>
<li>如果两个或以上类仅仅共享数据（非公共行为），应该让他们共同继承包含数据和方法的公共基类。</li>
<li>如果两个或以上类仅仅共享接口（而非实现），仅当它们将被多态使用时，它们应该继承自Java接口或公共基类。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>OOD</tag>
      </tags>
  </entry>
  <entry>
    <title>从代码review到浅谈面向对象</title>
    <url>/2020/12/20/review-code-practice/</url>
    <content><![CDATA[<p>周五进行了一次代码review，大部分业务问题和数据库设计问题在会上已经解决，但是代码质量(指的是封装，内聚，耦合，冗余，可读性，可测试性，javadoc)<br>提高空间还是很大，本文将从面向对象角度谈谈这个类的优缺点:</p>
<p>优点：<br>1 sonarlint扫描出来问题不多。大部分问题无痛关痒，5分钟内基本能改完。唯一注意的问题是方法圈复杂度过高。圈复杂度本质是需要切换过多思维理解代码，理论上一个圈复杂度就是一条代码路径，也就意味着加一个单元测试覆盖。</p>
<p><img src="/images/review-sonarlint.png" alt="sonarlint"></p>
<p>2 阿里p3c扫描出来问题也不多。才6个问题。值得注意的是“单个方法的总行数不超过80行”，这和sonarlint扫出来的是一样的。</p>
<p><img src="/images/review-p3c.png" alt="p3c"></p>
<p>3 Spotbug/FindBug扫出来0Bug.</p>
<p>4 IDEA INSPECT CODE 扫出来问题较多，327个，很多需要注意点，可以培养编程感觉，但是到达sonarlint和p3c已经不错了。</p>
<p><img src="/images/review-spotbug.png" alt="p3c"></p>
<p>可见基本的编程感觉已经逐步养成。基本的逻辑处理没有太大问题。</p>
<p>缺点：</p>
<p>1 分层角度：FinancialInvitationStatsServiceImpl层Mapper，Service，RpcClient混合出现，出现顺序没有分类，势必导致一个上帝类的出现。</p>
<p>2 可读性角度：可读性不好的标记是：“code review时候会说，快过，我们不想知道你的细节”。别人花费很多天写的角度，怎么可能在review这么短时间理解呢？本质反映了抽象层次达不到可以阅读的水平，这反映了阅读者不知道代码到底做了什么，只能找<br>一些明显可见或者可改可不改的问题来review。牛顿三大定律理解起来很容易，这是抽象，但是在奥赛题中关于三大定律的题目会非常难，这是细节。这样对被review人代码设计水平提高有限， 大量的数据库查询出现在这个类中，而不是见名知意短方法，会加大阅读者点击无关类的次数。可以将细节屏蔽些，在同一抽象层次做逻辑处理。</p>
<p>3 职责划分：类的协作者过于多，但是真正对外api只有一个，虽然接口有5个公开方法，也就意味着一个类只有一个个方法，而这个方法内协作者有12个，理解起来会困难。可以尝试拆分类，拆分职责，而不是被一个mapper一个service这种模式所束缚。</p>
<p>4 内聚性：类的内聚性明显很低，一个标志就是调用了不同的微服务。可以看到编写者试图提取接口，但是这块更好的是提取类，职责太散，也是内聚性不够的标准， 方法内聚性也低，大部分方法其实用到了很少的实例变量，而是没有用到实例变量的也没有设计为静态方法。还是可以尝试划分类。</p>
<p>5 耦合性，内聚性不好的类，耦合性当然高了。非常多的协作者，会导致你的类变得脆弱。这个类和谁耦合了？</p>
<p>6 可测试性为0，测试覆盖率为0。难以测试，难以验证是这个类最大的问题。因为难以测试，想出一个验证条件很复杂。因为难以测试，导致可读性不高。因为难以测试，导致类的职责划分看不到….</p>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>代码review</tag>
        <tag>好代码</tag>
        <tag>面向对象设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-高级架构师历年案例分析</title>
    <url>/2021/10/09/ruankao-architect-case-analysis/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>时间</th>
<th>考点</th>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>2020</td>
<td>软件架构设计</td>
<td>质量属性，架构风格</td>
</tr>
<tr>
<td></td>
<td>数据库模型设计</td>
<td>逻辑结构</td>
</tr>
<tr>
<td></td>
<td>分布式数据库</td>
<td>Redis数据结构，持久化策略，淘汰策略</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>MVC,非功能需求</td>
</tr>
<tr>
<td>2019</td>
<td>软件架构设计</td>
<td>软件质量属性，架构风格，</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>DFD，流程图</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>开放式架构</td>
</tr>
<tr>
<td></td>
<td>分布式数据库</td>
<td>缓存设计，数据一致性，缓存失效，雪崩，穿透</td>
</tr>
<tr>
<td></td>
<td>Web系统架构</td>
<td>非功能需求，MVC，SQL注入</td>
</tr>
<tr>
<td>2018</td>
<td>系统设计</td>
<td>非功能需求，瘦客户端CS架构</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>结构化方法和DFD，ERD，用例</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>实时任务简单任何和复杂任务区别，“腰”型通信模型架构</td>
</tr>
<tr>
<td></td>
<td>分布式数据库</td>
<td>memcache和redis，数据可靠性与一致性，redis集群切片</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>SOA，ESB，web安全</td>
</tr>
<tr>
<td>2017</td>
<td>软件架构评估</td>
<td>软件质量属性场景，质量属性效用树，架构风险，敏感点，权衡点</td>
</tr>
<tr>
<td></td>
<td>软件系统设计</td>
<td>MVC，EJB</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>ROS系统，</td>
</tr>
<tr>
<td></td>
<td>数据库设计</td>
<td>ORM，DAO，工厂设计模式</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>响应式WEB，主从复制，系统设计架构图填充</td>
</tr>
<tr>
<td>2016</td>
<td>软件架构设计</td>
<td>软件质量属性，管道过滤器和数据仓储风格对比，架构图完成</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>面向对象，用例图，类图</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>实时系统概念，实时特性分类，可靠性分析</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>J2EE，应用服务器，稳定性与扩展性</td>
</tr>
<tr>
<td></td>
<td>软件开发模型</td>
<td>scrum开发过程，MVC，分层架构</td>
</tr>
<tr>
<td>2015</td>
<td>软件架构评估</td>
<td>软件质量属性，软件属性效用树，系统风险，敏感点，权衡点，</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>状态图，活动图</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>系统可靠性，恢复块方法，N版本程序设计</td>
</tr>
<tr>
<td></td>
<td>分布式数据设计</td>
<td>关系型，文件系统，内存数据库，SQL设计</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>MVC，数据持久层好处，数据持久层技术</td>
</tr>
<tr>
<td>2014</td>
<td>系统架构设计</td>
<td>MVC，扩展接口模式，</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>DFD，CRUD矩阵</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>遗留工程，构件技术和标准</td>
</tr>
<tr>
<td></td>
<td>软件架构评估</td>
<td>质量属性效用树，系统风险，敏感点，权衡点</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>负载均衡，数据分区，MySQL主从，Memcache分布式缓存，磁盘IO问题</td>
</tr>
<tr>
<td>2013</td>
<td>企业应用集成</td>
<td>ESB，服务建模</td>
</tr>
<tr>
<td></td>
<td>项目管理</td>
<td>项目计划内容，项目绩效计算，项目延期解决方案</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>FMEA方法，软件风险优先级</td>
</tr>
<tr>
<td></td>
<td>设计模式与XML</td>
<td>MVC设计模式，XML界面管理计算</td>
</tr>
<tr>
<td></td>
<td>信息安全</td>
<td>公钥体系，数据库敏感字段加密</td>
</tr>
<tr>
<td>2012</td>
<td>软件架构设计</td>
<td>软件架构风格，不同风格的对比</td>
</tr>
<tr>
<td></td>
<td>分布式系统设计</td>
<td>ODP，进程间通信，分布式中间件</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>GOA开放架构设计，</td>
</tr>
<tr>
<td></td>
<td>设计模型</td>
<td>创建，结构，行为模式，设计模型选择和应用</td>
</tr>
<tr>
<td></td>
<td>分布式数据和可设计</td>
<td>NoSQL，关系型设计，NoSQL的优点和缺点</td>
</tr>
<tr>
<td>2011</td>
<td>软件架构评估</td>
<td>软件质量属性效用树，系统风险，敏感点和权衡点，</td>
</tr>
<tr>
<td></td>
<td>数据库设计</td>
<td>反范式化，数据库数据模型</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>嵌入式系统架构以及系统设计</td>
</tr>
<tr>
<td></td>
<td>Web系统设计</td>
<td>REST，数据获取，交互，访问设计</td>
</tr>
<tr>
<td></td>
<td>信息系统安全</td>
<td>对称加密与公钥加密，机密性和完整性机制，</td>
</tr>
<tr>
<td>2010</td>
<td>软件架构设计</td>
<td>软件架构风格，对比共享数据的主子程序和管道过滤器模式，</td>
</tr>
<tr>
<td></td>
<td>软件系统数据建模</td>
<td>单点故障，软化质量属性实现（集中式和分布式）</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>嵌入式操作系统，开放式架构</td>
</tr>
<tr>
<td></td>
<td>企业应用集成</td>
<td>ESB，</td>
</tr>
<tr>
<td></td>
<td>系统可靠性</td>
<td>动态冗余，N版本程序设计技术，检错技术</td>
</tr>
<tr>
<td>2009</td>
<td>软件架构设计</td>
<td>软件质量属性，软件质量属性的实现</td>
</tr>
<tr>
<td></td>
<td>软件系统建模</td>
<td>结构化建模，DFD，高质量DFD设计</td>
</tr>
<tr>
<td></td>
<td>嵌入式系统</td>
<td>TLS结构，嵌入式操作系统，可靠性设计</td>
</tr>
<tr>
<td></td>
<td>软件架构设计</td>
<td>软件架构风格，对比架构风格</td>
</tr>
<tr>
<td></td>
<td>软件安全</td>
<td>信息系统安全，认证方式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考试</category>
        <category>软考</category>
      </categories>
      <tags>
        <tag>高级架构师案例分析</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-高级架构师历年论文汇总</title>
    <url>/2021/10/07/ruankao-architect-paper/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>年份</th>
<th>1试题一</th>
<th>2试题二</th>
<th>3试题三</th>
<th>4试题四</th>
</tr>
</thead>
<tbody><tr>
<td>2020</td>
<td>论数据分片技术及其应用</td>
<td>论云原生架构及其应用</td>
<td>论软件测试中缺陷管理以及应用</td>
<td>论企业集成架构设计以及应用</td>
</tr>
<tr>
<td>2019</td>
<td>论负载均衡技术在Web系统中的应用</td>
<td>论数据湖技术及其应用</td>
<td>论软件系统架构评估及其应用</td>
<td>论软件设计方法以及应用</td>
</tr>
<tr>
<td>2018</td>
<td>论软件开发过程RUP以及应用</td>
<td>论软件体系结构的演化</td>
<td>论面向服务架构设计与应用</td>
<td><strong>论NoSQL数据库技术以及应用</strong></td>
</tr>
<tr>
<td>2017</td>
<td>论软件系统建模方法以及应用</td>
<td><strong>论软件架构风格</strong></td>
<td>论无服务器架构以及应用</td>
<td>论软件质量保证及其应用</td>
</tr>
<tr>
<td>2016</td>
<td><strong>论软件系统架构评估</strong></td>
<td><strong>论软件设计模式以及应用</strong></td>
<td>论数据访问层设计技术以及应用</td>
<td>论微服务架构及其应用</td>
</tr>
<tr>
<td>2015</td>
<td>论应用服务器基础软件</td>
<td>论软件系统架构风格</td>
<td><strong>论面向服务的架构及其应用</strong></td>
<td><strong>论企业集成平台的技术以及应用</strong></td>
</tr>
<tr>
<td>2014</td>
<td>论软件需求管理</td>
<td>论非功能性需求对企业应用架构设计的影响</td>
<td><strong>论软件的可靠性设计</strong></td>
<td>论网络安全体系设计</td>
</tr>
<tr>
<td>2013</td>
<td>论软件架构建模技术与应用</td>
<td><strong>论企业应用系统的分层架构风格</strong></td>
<td>论软件可靠性设计技术以及应用</td>
<td>论分布式存储系统架构设计</td>
</tr>
<tr>
<td>2012</td>
<td>论企业信息化规划的实施与应用</td>
<td>论决策支持系统的开发与应用</td>
<td>论企业应用系统的数据持久层架构设计</td>
<td>论基于架构的软件设计方法(ABSD)以及应用</td>
</tr>
<tr>
<td>2011</td>
<td>论模型驱动架构在系统开发中的应用</td>
<td>论企业集成平台的架构设计</td>
<td>论企业架构管理与应用</td>
<td>论软件需求获取技术以及应用</td>
</tr>
<tr>
<td>2010</td>
<td>论软件的静态演化和动态演化及其应用</td>
<td>论数据挖掘技术的应用</td>
<td>论大规模分布式系统缓存设计策略</td>
<td>论软件可靠性评价</td>
</tr>
<tr>
<td>2009</td>
<td>论基于DSSA的软件架构设计与应用</td>
<td>论信息系统建模方法</td>
<td>论基于REST服务的Web应用系统设计</td>
<td>论软件可靠性设计与应用</td>
</tr>
</tbody></table>
<p><strong>往年考题需要针对几个类型去练习</strong>：</p>
<p>1 架构风格</p>
<p>2 面向服务的架构</p>
<p>3 架构评估</p>
<p>4 企业应用集成</p>
<p>5 软件可靠性设计</p>
<p>6 多层架构</p>
<p>7 设计模式</p>
<p><strong>时间规划</strong></p>
<p>2021-10-10  软件架构风格</p>
<p>2021-11-16  设计模式</p>
<p>2021-11-17  面向服务的架构</p>
<p>2021-11-23 企业应用集成</p>
<p>2021-11-24 多层架构</p>
<p>2021-11-30 架构评估</p>
<p>2021-11-31 软件可靠性设计</p>
]]></content>
      <categories>
        <category>考试</category>
        <category>软考</category>
      </categories>
      <tags>
        <tag>高级架构师论文</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-高级架构师历年综合知识</title>
    <url>/2021/09/13/ruankao-architect-comprehensive-knowledge/</url>
    <content><![CDATA[<p>每日一练最后一列：<a href="https://www.educity.cn/tiku/dp100110011003-43.html" target="_blank" rel="noopener">https://www.educity.cn/tiku/dp100110011003-43.html</a></p>
<p>分数评比：</p>
<p>67.5-75 优秀(90-100)</p>
<p>60-67.5 良好(80-90)</p>
<p>45-60 及格(60-80)</p>
<p>45以下 不及格(60以下)</p>
<p>2009年2020年，11年考题。准备考试时间从2021-08-31号开始。</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>类型</th>
<th>测试报告</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>2009</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=18951089" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=18951089</a></td>
<td>49</td>
</tr>
<tr>
<td></td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20674226" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20674226</a></td>
<td>60</td>
</tr>
<tr>
<td>2009</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=18991552" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=18991552</a></td>
<td>0</td>
</tr>
<tr>
<td>2009</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723180" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723180</a></td>
<td>0</td>
</tr>
<tr>
<td>2010</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=18979952" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=18979952</a></td>
<td>50</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20702165" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20702165</a></td>
<td>61</td>
</tr>
<tr>
<td>2010</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723068" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723068</a></td>
<td>0</td>
</tr>
<tr>
<td>2010</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723204" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723204</a></td>
<td>0</td>
</tr>
<tr>
<td>2011</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19028653" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19028653</a></td>
<td>52</td>
</tr>
<tr>
<td></td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20719531" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20719531</a></td>
<td>64</td>
</tr>
<tr>
<td>2011</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723282" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723282</a></td>
<td>0</td>
</tr>
<tr>
<td>2011</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723101" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723101</a></td>
<td>0</td>
</tr>
<tr>
<td>2012</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19200689" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19200689</a></td>
<td>47</td>
</tr>
<tr>
<td></td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20723550" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20723550</a></td>
<td>62</td>
</tr>
<tr>
<td>2012</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20728268" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20728268</a></td>
<td></td>
</tr>
<tr>
<td>2012</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20728304" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20728304</a></td>
<td></td>
</tr>
<tr>
<td>2013</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19488274" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19488274</a></td>
<td>40</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20728338" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20728338</a></td>
<td>60</td>
</tr>
<tr>
<td>2013</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20729999" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20729999</a></td>
<td></td>
</tr>
<tr>
<td>2013</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20730013" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20730013</a></td>
<td></td>
</tr>
<tr>
<td>2014</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19562008" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19562008</a></td>
<td>46</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=20735393" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=20735393</a></td>
<td>59</td>
</tr>
<tr>
<td>2014</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180440" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180440</a></td>
<td></td>
</tr>
<tr>
<td>2014</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180468" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180468</a></td>
<td></td>
</tr>
<tr>
<td>2015</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19394496" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19394496</a></td>
<td>51</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21031654" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21031654</a></td>
<td>63</td>
</tr>
<tr>
<td>2015</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180523" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180523</a></td>
<td></td>
</tr>
<tr>
<td>2015</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180495" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180495</a></td>
<td></td>
</tr>
<tr>
<td>2016</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19331712" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19331712</a></td>
<td>42</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21175344" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21175344</a></td>
<td>55</td>
</tr>
<tr>
<td>2016</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180541" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180541</a></td>
<td></td>
</tr>
<tr>
<td>2016</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180560" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180560</a></td>
<td></td>
</tr>
<tr>
<td>2017</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19241523" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19241523</a></td>
<td>50</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21180641" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21180641</a></td>
<td>56</td>
</tr>
<tr>
<td>2017</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21182428" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21182428</a></td>
<td></td>
</tr>
<tr>
<td>2017</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21182438" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21182438</a></td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19211415" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19211415</a></td>
<td>54</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21183026" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21183026</a></td>
<td>64</td>
</tr>
<tr>
<td>2018</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19435318" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19435318</a></td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21182374" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21182374</a></td>
<td></td>
</tr>
<tr>
<td>2019</td>
<td>综合知识</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=19095458" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=19095458</a></td>
<td>47</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2019</td>
<td>案例分析</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=21182466" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=21182466</a></td>
<td></td>
</tr>
<tr>
<td>2019</td>
<td>论文</td>
<td><a href="https://uc.educity.cn/tiku/testReport.html?id=18720605" target="_blank" rel="noopener">https://uc.educity.cn/tiku/testReport.html?id=18720605</a></td>
<td></td>
</tr>
<tr>
<td>2020</td>
<td>综合知识</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2020</td>
<td>案例分析</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2020</td>
<td>论文</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>每日练习</th>
<th>测试报告</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考试</category>
        <category>软考</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL表情况概览</title>
    <url>/2023/01/19/slow-sql-optimization/</url>
    <content><![CDATA[<h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show table status like &#39;%table_x&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> SELECT</span><br><span class="line">    table_name,</span><br><span class="line">    engine,</span><br><span class="line">    row_format,</span><br><span class="line">    table_rows,</span><br><span class="line">    avg_row_length AS avg_row,</span><br><span class="line">    ROUND((data_length + index_length) &#x2F; 1024 &#x2F; 1024,</span><br><span class="line">            2) AS total_mb,</span><br><span class="line">    ROUND((data_length) &#x2F; 1024 &#x2F; 1024, 2) AS data_mb,</span><br><span class="line">    ROUND((index_length) &#x2F; 1024 &#x2F; 1024, 2) AS index_mb</span><br><span class="line">FROM</span><br><span class="line">    information_schema.tables</span><br><span class="line">WHERE</span><br><span class="line">    table_schema &#x3D; &#39;xxx&#39;</span><br><span class="line">AND table_name &#x3D; &#39;yyy&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from table_x;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc table_x;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table table_x;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT xxx)&#x2F;COUNT(*) AS xxx_selectivity,COUNT(*) AS total  FROM table_x;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information</a></p>
<p>order优化：<a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html</a></p>
<p>groupby优化：<a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>lintcode解题记录</title>
    <url>/2019/01/01/lintcode-algorithm/</url>
    <content><![CDATA[<p>本文章是一个系列，主要记录自己解算法题的一个记录，每道题会出一篇解题报告，作为自己算法功底的沉淀。每次迭代全部从头开始，并且记录以日期。</p>
<p>下面记录的必须在ide和lintcode上提交过，并且写过代码的。</p>
<p>解题七步曲：1 倾听问题，2样本确认， 3 动口不动手的暴力天然解， 4 动口也动手的最优解，5 路演你的思路，6 结构化的编码，7 单元测试     </p>
<p>我的笔记：<a href="https://www.lintcode.com/note/?user__username=xiaozhiliaoo" target="_blank" rel="noopener">here</a>  (复习时候，刷这个效率更高)</p>
<p>我AC的题目：<a href="https://www.lintcode.com/problem/?user_status=accepted" target="_blank" rel="noopener">here</a></p>
<table>
<thead>
<tr>
<th>No</th>
<th>Problem</th>
<th>Describe</th>
<th>Type</th>
<th>Diffculty</th>
<th>Note</th>
<th>Date1</th>
<th>Date2</th>
<th>Date3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="https://www.lintcode.com/problem/implement-strstr/description" target="_blank" rel="noopener">13-implement-strstr</a></td>
<td>字符串查找</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><a href="https://www.lintcode.com/problem/594/" target="_blank" rel="noopener">594-strstr-ii</a></td>
<td>字符串查找 II</td>
<td>hash,kmp</td>
<td>Hard</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.lintcode.com/problem/17/" target="_blank" rel="noopener">17-subsets</a></td>
<td>子集(无重复)</td>
<td>combination,dfs</td>
<td>Medium</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.lintcode.com/problem/18/" target="_blank" rel="noopener">18-subsets-ii</a></td>
<td>子集 II(有重复)</td>
<td>dfs,backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td><a href="https://www.lintcode.com/problem/1361/" target="_blank" rel="noopener">1361-text-justification</a></td>
<td>文字并排</td>
<td>simulation</td>
<td>Hard</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.lintcode.com/problem/38/" target="_blank" rel="noopener">38-search-a-2d-matrix-ii</a></td>
<td>搜索二维矩阵 II</td>
<td>sort-matrix</td>
<td>Medium</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td><a href="https://www.lintcode.com/problem/recover-rotated-sorted-array" target="_blank" rel="noopener">39-recover-rotated-sorted-array</a></td>
<td>恢复旋转排序数组</td>
<td>sort-array</td>
<td>Easy</td>
<td></td>
<td>2020/6/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td><a href="https://www.lintcode.com/problem/573/" target="_blank" rel="noopener">573-build-post-office-ii</a></td>
<td>邮局的建立 II</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/6/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td><a href="https://www.lintcode.com/problem/616/" target="_blank" rel="noopener">616-course-schedule-ii</a></td>
<td>安排课程</td>
<td>bfs,topological-sort</td>
<td>Medium</td>
<td></td>
<td>2020/6/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.lintcode.com/problem/598/" target="_blank" rel="noopener">598-zombie-in-matrix</a></td>
<td>僵尸矩阵</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/6/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><a href="https://www.lintcode.com/problem/127/" target="_blank" rel="noopener">127-topological-sorting</a></td>
<td>拓扑排序</td>
<td>bfs or dfs</td>
<td>Medium</td>
<td></td>
<td>2020/6/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.lintcode.com/problem/433/" target="_blank" rel="noopener">433-number-of-islands</a></td>
<td>岛屿的个数</td>
<td>bfs or union-find</td>
<td>Easy</td>
<td></td>
<td>2020/6/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.lintcode.com/problem/number-of-big-islands/" target="_blank" rel="noopener">677-number-of-big-islands</a></td>
<td>大岛的数量</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/6/22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.lintcode.com/problem/109/" target="_blank" rel="noopener">109-triangle</a></td>
<td>数字三角形</td>
<td>dp，坐标型</td>
<td>Medium</td>
<td></td>
<td>2020/6/22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><a href="https://www.lintcode.com/problem/110" target="_blank" rel="noopener">110-minimum-path-sum</a></td>
<td>最小路径和</td>
<td>dp</td>
<td>Easy</td>
<td></td>
<td>2020/6/22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><a href="https://www.lintcode.com/problem/114/" target="_blank" rel="noopener">114-unique-paths</a></td>
<td>不同的路径</td>
<td>dp，坐标型号dp</td>
<td>Easy</td>
<td></td>
<td>2020/6/22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.lintcode.com/problem/99" target="_blank" rel="noopener">99-reorder-list</a></td>
<td>重排链表</td>
<td>LinkedList</td>
<td>Medium</td>
<td></td>
<td>2020/6/22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td><a href="https://www.lintcode.com/problem/174/" target="_blank" rel="noopener">174-remove-nth-node-from-end-of-list</a></td>
<td>删除链表中倒数第n个节点</td>
<td>LinkedList</td>
<td>Easy</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td><a href="https://www.lintcode.com/problem/102/" target="_blank" rel="noopener">102-linked-list-cycle</a></td>
<td>带环链表</td>
<td>LinkedList</td>
<td>Medium</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td><a href="https://www.lintcode.com/problem/103/" target="_blank" rel="noopener">103-linked-list-cycle-ii</a></td>
<td>带环链表 返回环起点值</td>
<td>LinkedList</td>
<td>Hard</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td><a href="https://www.lintcode.com/problem/104/" target="_blank" rel="noopener">104-merge-k-sorted-lists</a></td>
<td>合并k个排序链表</td>
<td>LinkedList</td>
<td>Medium</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td><a href="https://www.lintcode.com/problem/105/" target="_blank" rel="noopener">105-copy-list-with-random-pointer</a></td>
<td>复制带随机指针的链表</td>
<td>LinkedList</td>
<td>Medium</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td><a href="https://www.lintcode.com/problem/106/" target="_blank" rel="noopener">106-convert-sorted-list-to-binary-search-tree</a></td>
<td>有序链表转换为二叉搜索树</td>
<td>LinkedList</td>
<td>Medium</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td><a href="https://www.lintcode.com/problem/177/" target="_blank" rel="noopener">177-convert-sorted-array-to-binary-search-tree-with-minimal-height</a></td>
<td>把排序数组转换为高度最小的二叉搜索树</td>
<td>LinkedList</td>
<td>Easy</td>
<td></td>
<td>2020/6/23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td><a href="https://www.lintcode.com/problem/74/" target="_blank" rel="noopener">74 first-bad-version</a></td>
<td>第一个错误的代码版本</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td><a href="https://www.lintcode.com/problem/1496/" target="_blank" rel="noopener">1496  implement-rand10-using-rand7</a></td>
<td>用Rand7()实现Rand10()</td>
<td>simulation</td>
<td>Medium</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td><a href="https://www.lintcode.com/problem/66/" target="_blank" rel="noopener">66  binary-tree-preorder-traversal</a></td>
<td>二叉树的前序遍历</td>
<td>Tree，recursion and iteration(Stack)</td>
<td>Easy</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td><a href="https://www.lintcode.com/problem/67/" target="_blank" rel="noopener">67  binary-tree-inorder-traversal</a></td>
<td>二叉树的中序遍历</td>
<td>Tree，recursion and iteration(Stack)</td>
<td>Easy</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td><a href="https://www.lintcode.com/problem/68/" target="_blank" rel="noopener">68  binary-tree-postorder-traversal</a></td>
<td>二叉树的后序遍历</td>
<td>Tree，recursion and iteration(Stack)</td>
<td>Easy</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td><a href="https://www.lintcode.com/problem/86/" target="_blank" rel="noopener">86  binary-search-tree-iterator</a></td>
<td>二叉查找树迭代器</td>
<td>Tree</td>
<td>Hard</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td><a href="https://www.lintcode.com/problem/97/" target="_blank" rel="noopener">97  maximum-depth-of-binary-tree</a></td>
<td>二叉树的最大深度</td>
<td>DC</td>
<td>Easy</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td><a href="https://www.lintcode.com/problem/93/" target="_blank" rel="noopener">93  balanced-binary-tree</a></td>
<td>是否是平衡二叉树</td>
<td>DC，Recursion</td>
<td>Easy</td>
<td></td>
<td>2020/6/24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td><a href="https://www.lintcode.com/problem/31/" target="_blank" rel="noopener">31  partition-array</a></td>
<td>数组划分</td>
<td>Array,Quick Sort，Two Pointer</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td><a href="https://www.lintcode.com/problem/94/" target="_blank" rel="noopener">94  binary-tree-maximum-path-sum</a></td>
<td>二叉树中的最大路径和</td>
<td>DC</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td><a href="https://www.lintcode.com/problem/88/" target="_blank" rel="noopener">88  lowest-common-ancestor-of-a-binary-tree</a></td>
<td>最近公共祖先(LCA)</td>
<td>DC,RE，LCA</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td><a href="https://www.lintcode.com/problem/69/" target="_blank" rel="noopener">69  binary-tree-level-order-traversal</a></td>
<td>二叉树的层次遍历</td>
<td>BFS,Queue</td>
<td>Easy</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td><a href="https://www.lintcode.com/problem/70/" target="_blank" rel="noopener">70  binary-tree-level-order-traversal-ii</a></td>
<td>二叉树的层次遍历 II</td>
<td>BFS</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td><a href="https://www.lintcode.com/problem/95/" target="_blank" rel="noopener">95  validate-binary-search-tree</a></td>
<td>验证二叉查找树</td>
<td>traversal</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td><a href="https://www.lintcode.com/problem/85/" target="_blank" rel="noopener">85  insert-node-in-a-binary-search-tree</a></td>
<td>在二叉查找树中插入节点</td>
<td>BST，分治</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td><a href="https://www.lintcode.com/problem/86/" target="_blank" rel="noopener">86  binary-search-tree-iterator</a></td>
<td>在二叉查找树中插入节点</td>
<td>BST，分治</td>
<td>Hard</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td><a href="https://www.lintcode.com/problem/87/" target="_blank" rel="noopener">87  remove-node-in-binary-search-tree</a></td>
<td>删除二叉查找树的节点</td>
<td>BST，分治</td>
<td>Hard</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td><a href="https://www.lintcode.com/problem/11/" target="_blank" rel="noopener">11  search-range-in-binary-search-tree</a></td>
<td>二叉查找树中搜索区间</td>
<td>tree-traversal</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td><a href="https://www.lintcode.com/problem/12/" target="_blank" rel="noopener">12  min-stack</a></td>
<td>最小栈</td>
<td>stack，Simulation</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>43</td>
<td><a href="https://www.lintcode.com/problem/40/" target="_blank" rel="noopener">40  implement-queue-by-two-stacks</a></td>
<td>双栈实现队列</td>
<td>stack，Simulation</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>44</td>
<td><a href="https://www.lintcode.com/problem/494/" target="_blank" rel="noopener">494-implement-stack-by-two-queues</a></td>
<td>双队列实现栈</td>
<td>queue</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>45</td>
<td><a href="https://www.lintcode.com/problem/130/" target="_blank" rel="noopener">130  heapify</a></td>
<td>堆化</td>
<td>heap</td>
<td>Medium</td>
<td></td>
<td>2020/6/25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>46</td>
<td><a href="https://www.lintcode.com/problem/158/" target="_blank" rel="noopener">158  valid-anagram</a></td>
<td>两个字符串是变位词</td>
<td>string,map</td>
<td>Easy</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>47</td>
<td><a href="https://www.lintcode.com/problem/122/" target="_blank" rel="noopener">122  largest-rectangle-in-histogram</a></td>
<td>直方图最大矩形覆盖</td>
<td>monotonic stack</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>48</td>
<td><a href="https://www.lintcode.com/problem/126/" target="_blank" rel="noopener">126-max-tree</a></td>
<td>最大树</td>
<td>monotonic stack</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>49</td>
<td><a href="https://www.lintcode.com/problem/134/" target="_blank" rel="noopener">134-lru  cache</a></td>
<td>LRU缓存策略</td>
<td>hash</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>50</td>
<td><a href="https://www.lintcode.com/problem/24/" target="_blank" rel="noopener">24-lfu  cache</a></td>
<td>LFU缓存</td>
<td>hash</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>51</td>
<td><a href="https://www.lintcode.com/problem/129/" target="_blank" rel="noopener">129-rehashing</a></td>
<td>重哈希</td>
<td>hash</td>
<td>Medium</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>52</td>
<td><a href="https://www.lintcode.com/problem/171/" target="_blank" rel="noopener">171-anagrams</a></td>
<td>变位词</td>
<td>hash</td>
<td>Medium</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>53</td>
<td><a href="https://www.lintcode.com/problem/138/" target="_blank" rel="noopener">138-subarray-sum</a></td>
<td>子数组之和</td>
<td>hash，前缀和</td>
<td>Easy</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>54</td>
<td><a href="https://www.lintcode.com/problem/124/" target="_blank" rel="noopener">124-longest-consecutive-sequence</a></td>
<td>最长连续序列</td>
<td>hash</td>
<td>Medium</td>
<td></td>
<td>2020/6/26</td>
<td>2021/2/13</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td><a href="https://www.lintcode.com/problem/81/" target="_blank" rel="noopener">81-find-median-from-data-stream</a></td>
<td>数据流中位数</td>
<td>heap</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>56</td>
<td><a href="https://www.lintcode.com/problem/132/" target="_blank" rel="noopener">132-word-search-ii</a></td>
<td>单词搜索 II</td>
<td>trie</td>
<td>Hard</td>
<td></td>
<td>2020/6/26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>57</td>
<td><a href="https://www.lintcode.com/problem/442/" target="_blank" rel="noopener">442-implement-trie-prefix-tree</a></td>
<td>实现 Trie（前缀树）</td>
<td>trie</td>
<td></td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>58</td>
<td><a href="https://www.lintcode.com/problem/61/" target="_blank" rel="noopener">61-search-for-a-range</a></td>
<td>搜索区间(对比<a href="https://www.lintcode.com/problem/138/" target="_blank" rel="noopener">138</a>)</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td>2021/2/13</td>
<td></td>
</tr>
<tr>
<td>59</td>
<td><a href="https://www.lintcode.com/problem/60/" target="_blank" rel="noopener">60-search-insert-position</a></td>
<td>搜索插入位置</td>
<td>binarysearch</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>60</td>
<td><a href="https://www.lintcode.com/problem/28/" target="_blank" rel="noopener">28-search-a-2d-matrix</a></td>
<td>搜索二维矩阵</td>
<td>binarysearch</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>61</td>
<td><a href="https://www.lintcode.com/problem/75/" target="_blank" rel="noopener">75-find-peak-element</a></td>
<td>寻找峰值</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>62</td>
<td><a href="https://www.lintcode.com/problem/62/" target="_blank" rel="noopener">62-search-in-rotated-sorted-array(无重复)</a></td>
<td>搜索旋转排序数组</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>63</td>
<td><a href="https://www.lintcode.com/problem/63/" target="_blank" rel="noopener">63-search-in-rotated-sorted-array-ii(有重复)</a></td>
<td>搜索旋转排序数组</td>
<td>62 follow up</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>64</td>
<td><a href="https://www.lintcode.com/problem/6/" target="_blank" rel="noopener">6-merge-two-sorted-arrays</a></td>
<td>合并排序数组 II</td>
<td>Two Pointers</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>65</td>
<td><a href="https://www.lintcode.com/problem/64/" target="_blank" rel="noopener">64-merge-sorted-array</a></td>
<td>合并排序数组</td>
<td>Two Pointers</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>66</td>
<td><a href="https://www.lintcode.com/problem/159/" target="_blank" rel="noopener">159-find-minimum-in-rotated-sorted-array</a></td>
<td>寻找旋转排序数组中的最小值(无重复)</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>67</td>
<td><a href="https://www.lintcode.com/problem/160/" target="_blank" rel="noopener">160-find-minimum-in-rotated-sorted-array-ii</a></td>
<td>寻找旋转排序数组中的最小值(有重复)</td>
<td>binarysearch</td>
<td>Medium</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>68</td>
<td><a href="https://www.lintcode.com/problem/65/" target="_blank" rel="noopener">65-median-of-two-sorted-arrays</a></td>
<td>两个排序数组的中位数</td>
<td>binarysearch,FindKMax</td>
<td>Hard</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>69</td>
<td><a href="https://www.lintcode.com/problem/8/" target="_blank" rel="noopener">8-rotate-string</a></td>
<td>旋转字符串</td>
<td>string，simulation，三步翻转法</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>70</td>
<td><a href="https://www.lintcode.com/problem/53/" target="_blank" rel="noopener">53-reverse-words-in-a-string</a></td>
<td>翻转字符串中的单词</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2020/6/27</td>
<td></td>
<td></td>
</tr>
<tr>
<td>71</td>
<td><a href="https://www.lintcode.com/problem/241/" target="_blank" rel="noopener">241-string-to-integer</a></td>
<td>转换字符串到整数</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>72</td>
<td><a href="https://www.lintcode.com/problem/1510/" target="_blank" rel="noopener">1510-buddy-strings</a></td>
<td>亲密字符串</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>73</td>
<td><a href="https://www.lintcode.com/problem/415/" target="_blank" rel="noopener">415-valid-palindrome</a></td>
<td>有效回文串</td>
<td>string，双指针</td>
<td>Medium</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>74</td>
<td><a href="https://www.lintcode.com/problem/767/" target="_blank" rel="noopener">767-reverse-array</a></td>
<td>翻转数组</td>
<td>string，reverse</td>
<td>Easy</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>75</td>
<td><a href="https://www.lintcode.com/problem/1283/" target="_blank" rel="noopener">1283-reverse-string</a></td>
<td>翻转字符串</td>
<td>string，reverse</td>
<td>Easy</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>76</td>
<td><a href="https://www.lintcode.com/problem/78/" target="_blank" rel="noopener">78-longest-common-prefix</a></td>
<td>最长公共前缀 (LCP)</td>
<td>string。Simulation</td>
<td>Medium</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>77</td>
<td><a href="https://www.lintcode.com/problem/1263/" target="_blank" rel="noopener">1263-is-subsequence</a></td>
<td>是子序列吗</td>
<td>string，Simulation</td>
<td>Medium</td>
<td></td>
<td>2020/6/28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>78</td>
<td><a href="https://www.lintcode.com/problem/384/" target="_blank" rel="noopener">384-longest-substring-without-repeating-characters</a></td>
<td>最长无重复字符的子串</td>
<td>string，two pointer</td>
<td>Medium</td>
<td></td>
<td>2020/6/29</td>
<td>2021/2/14</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td><a href="https://www.lintcode.com/problem/213/" target="_blank" rel="noopener">213-string-compression</a></td>
<td>字符串压缩</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2020/6/29</td>
<td></td>
<td></td>
</tr>
<tr>
<td>80</td>
<td><a href="https://www.lintcode.com/problem/1352/" target="_blank" rel="noopener">1352-compare-version-numbers</a></td>
<td>比较版本号</td>
<td>string</td>
<td>Medium</td>
<td></td>
<td>2020/6/29</td>
<td></td>
<td></td>
</tr>
<tr>
<td>81</td>
<td><a href="https://www.lintcode.com/problem/1542/" target="_blank" rel="noopener">1542-nexttime-norepeat</a></td>
<td>下一个不重复的时间</td>
<td>string</td>
<td>Medium</td>
<td></td>
<td>2020/6/29</td>
<td></td>
<td></td>
</tr>
<tr>
<td>82</td>
<td><a href="https://www.lintcode.com/problem/192/" target="_blank" rel="noopener">192-wildcard-matching</a></td>
<td>通配符匹配</td>
<td>string，DFS</td>
<td>Hard</td>
<td></td>
<td>2020/6/30</td>
<td></td>
<td></td>
</tr>
<tr>
<td>83</td>
<td><a href="https://www.lintcode.com/problem/98/" target="_blank" rel="noopener">98-sort-list（排序链表）</a></td>
<td>链表排序(归并和快速)</td>
<td>sort</td>
<td>Medium</td>
<td></td>
<td>2020/6/30</td>
<td></td>
<td></td>
</tr>
<tr>
<td>84</td>
<td><a href="https://www.lintcode.com/problem/463/" target="_blank" rel="noopener">463-sort-integers</a></td>
<td>整数排序</td>
<td>sort【直接选择(选择)，冒泡排序(交换)，直接插入排序(插入)】</td>
<td>Native</td>
<td>简单排序</td>
<td>2020/6/30</td>
<td></td>
<td></td>
</tr>
<tr>
<td>85</td>
<td><a href="https://www.lintcode.com/problem/464/" target="_blank" rel="noopener">464-sort-integers-ii </a></td>
<td>整数排序2</td>
<td>sort【堆排序(选择)，快排(交换)，归并排序(归并)】</td>
<td>Medium</td>
<td>分治排序</td>
<td>2020/6/30</td>
<td></td>
<td></td>
</tr>
<tr>
<td>86</td>
<td><a href="https://www.lintcode.com/problem/136/" target="_blank" rel="noopener">136-palindrome-partitioning</a></td>
<td>分割回文串</td>
<td>组合型DFS+Backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/7/1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>87</td>
<td><a href="https://www.lintcode.com/problem/77/" target="_blank" rel="noopener">77-longest-common-subsequence</a></td>
<td>最长公共子序列(LCS)</td>
<td>match-dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>88</td>
<td><a href="https://www.lintcode.com/problem/79/" target="_blank" rel="noopener">79-longest-common-substring</a></td>
<td>最长公共子串(LCS)</td>
<td>Two Sequences DP</td>
<td>Medium</td>
<td></td>
<td>2020/7/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>89</td>
<td><a href="https://www.lintcode.com/problem/680/" target="_blank" rel="noopener">680-spilt-string</a></td>
<td>分割字符串</td>
<td>组合型DFS+Backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/7/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>90</td>
<td><a href="https://www.lintcode.com/problem/15/" target="_blank" rel="noopener">15-permutations</a></td>
<td>全排列</td>
<td>排列型DFS+Backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/7/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>91</td>
<td><a href="https://www.lintcode.com/problem/16/" target="_blank" rel="noopener">16-permutations-ii</a></td>
<td>全排列</td>
<td>排列型DFS+Backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/7/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>92</td>
<td><a href="https://www.lintcode.com/problem/669/" target="_blank" rel="noopener">669-coin-change</a></td>
<td>换硬币</td>
<td>无限背包,DFS,DP,不用回溯</td>
<td></td>
<td></td>
<td>2020/7/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>93</td>
<td><a href="https://www.lintcode.com/problem/816/" target="_blank" rel="noopener">816-traveling-salesman-problem</a></td>
<td>旅行商问题</td>
<td>排列型DFS，pruning,dp,旅行售货员问题，TSP问题，组合优化</td>
<td>Hard</td>
<td></td>
<td>2020/7/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>94</td>
<td><a href="https://www.lintcode.com/problem/1147/" target="_blank" rel="noopener">1147-work-plan</a></td>
<td>工作安排</td>
<td>coordinate-dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>95</td>
<td><a href="https://www.lintcode.com/problem/76/" target="_blank" rel="noopener">76-longest-increasing-subsequence</a></td>
<td>最长上升子序列(LIS)</td>
<td>match-dp，LIS</td>
<td>Medium</td>
<td></td>
<td>2020/7/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>96</td>
<td><a href="https://www.lintcode.com/problem/91/" target="_blank" rel="noopener">91-minimum-adjustment-cost</a></td>
<td>最小调整代价</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>97</td>
<td><a href="https://www.lintcode.com/problem/34/" target="_blank" rel="noopener">34-n-queens-ii</a></td>
<td>N皇后问题（方案数）</td>
<td>Backtracking+DFS</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>98</td>
<td><a href="https://www.lintcode.com/problem/33/" target="_blank" rel="noopener">33-n-queens</a></td>
<td>N皇后问题（具体方案）</td>
<td>Backtracking+DFS</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>99</td>
<td><a href="https://www.lintcode.com/problem/622/" target="_blank" rel="noopener">622-frog-jump</a></td>
<td>青蛙跳</td>
<td>DFS，DP</td>
<td>Hard</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td><a href="https://www.lintcode.com/problem/602/" target="_blank" rel="noopener">602-russian-doll-envelopes</a></td>
<td>俄罗斯套娃信封</td>
<td>dfs(指数级),dp(正解)</td>
<td>Hard</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>101</td>
<td><a href="https://www.lintcode.com/problem/116/" target="_blank" rel="noopener">116-jump-game</a></td>
<td>跳跃游戏</td>
<td>单序列dp(可行性)，贪心</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>102</td>
<td><a href="https://www.lintcode.com/problem/117/" target="_blank" rel="noopener">117-jump-game-ii</a></td>
<td>跳跃游戏</td>
<td>单序列dp(最小值)</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>103</td>
<td><a href="https://www.lintcode.com/problem/149/" target="_blank" rel="noopener">149-best-time-to-buy-and-sell-stock</a></td>
<td>买卖股票的最佳时机（一次交易）</td>
<td>单序列dp(最大值)</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>104</td>
<td><a href="https://www.lintcode.com/problem/115/" target="_blank" rel="noopener">115-unique-paths-ii</a></td>
<td>不同的路径 II</td>
<td>坐标DP</td>
<td>Easy</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>105</td>
<td><a href="https://www.lintcode.com/problem/111/" target="_blank" rel="noopener">111-climbing-stairs</a></td>
<td>爬楼梯</td>
<td>单序列dp(计数问题)</td>
<td>Easy</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>106</td>
<td><a href="https://www.lintcode.com/problem/563/" target="_blank" rel="noopener">563-backpack-v</a></td>
<td>背包问题 V</td>
<td>Backpack DP</td>
<td>Medium</td>
<td></td>
<td>2020/7/4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>107</td>
<td><a href="https://www.lintcode.com/problem/630/" target="_blank" rel="noopener">630-knight-shortest-path-ii</a></td>
<td>骑士的最短路径II</td>
<td>坐标dp, 单向BFS-&gt;双向BFS</td>
<td>Medium</td>
<td></td>
<td>2020/7/6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>108</td>
<td><a href="https://www.lintcode.com/problem/564/" target="_blank" rel="noopener">564-combination-sum-iv(backpack-vi)</a></td>
<td>组合总和 IV</td>
<td>单序列dp，Backpack DP</td>
<td>Medium</td>
<td></td>
<td>2020/7/6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>109</td>
<td><a href="https://www.lintcode.com/problem/512/" target="_blank" rel="noopener">512-decode-ways</a></td>
<td>解码方法</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>110</td>
<td><a href="https://www.lintcode.com/problem/589/" target="_blank" rel="noopener">589-connecting-graph</a></td>
<td>连接图</td>
<td>union-find</td>
<td>Medium</td>
<td></td>
<td>2020/7/7</td>
<td>2021/2/14</td>
<td></td>
</tr>
<tr>
<td>111</td>
<td><a href="https://www.lintcode.com/problem/752/" target="_blank" rel="noopener">752-rogue-knight-sven</a></td>
<td>流浪剑客斯温</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>112</td>
<td><a href="https://www.lintcode.com/problem/590/" target="_blank" rel="noopener">590-connecting-graph-ii</a></td>
<td>连接图</td>
<td>union-find</td>
<td>Medium</td>
<td></td>
<td>2020/7/8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>113</td>
<td><a href="https://www.lintcode.com/problem/360/" target="_blank" rel="noopener">360-sliding-window-median</a></td>
<td>滑动窗口的中位数</td>
<td>heap，Sliding Window</td>
<td>Hard</td>
<td></td>
<td>2020/7/8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>114</td>
<td><a href="https://www.lintcode.com/problem/401/" target="_blank" rel="noopener">401-kth-smallest-number-in-sorted-matrix</a></td>
<td>排序矩阵中的从小到大第k个数</td>
<td>heap</td>
<td>Medium</td>
<td></td>
<td>2020/7/8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>115</td>
<td><a href="https://www.lintcode.com/problem/362/" target="_blank" rel="noopener">362-sliding-window-maximum</a></td>
<td>滑动窗口的最大值</td>
<td>monotonic-queue</td>
<td>Hard</td>
<td></td>
<td>2020/7/8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>116</td>
<td><a href="https://www.lintcode.com/problem/178/" target="_blank" rel="noopener">178-graph-valid-tree</a></td>
<td>图是否是树</td>
<td>union-find</td>
<td>Medium</td>
<td></td>
<td>2020/7/8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>117</td>
<td><a href="https://www.lintcode.com/problem/434/" target="_blank" rel="noopener">434-number-of-islands-ii</a></td>
<td>岛屿的个数II</td>
<td>union-find</td>
<td>Medium</td>
<td></td>
<td>2020/7/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>118</td>
<td><a href="https://www.lintcode.com/problem/430/" target="_blank" rel="noopener">430-scramble-string</a></td>
<td>攀爬字符串</td>
<td>dfs+pruning</td>
<td>Hard</td>
<td></td>
<td>2020/7/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>119</td>
<td><a href="https://www.lintcode.com/problem/802/" target="_blank" rel="noopener">802-sudoku-solver</a></td>
<td>数独</td>
<td>dfs+pruning+backtracking</td>
<td>Hard</td>
<td></td>
<td>2020/7/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>120</td>
<td><a href="https://www.lintcode.com/problem/121/" target="_blank" rel="noopener">121-word-ladder-ii</a></td>
<td>单词接龙 II</td>
<td>dfs+pruning+backtracking</td>
<td>Hard</td>
<td></td>
<td>2020/7/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>121</td>
<td><a href="https://www.lintcode.com/problem/582/" target="_blank" rel="noopener">582-word-break-ii</a></td>
<td>单词拆分II</td>
<td>dfs+pruning+backtracking</td>
<td>Hard</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>122</td>
<td><a href="https://www.lintcode.com/problem/652/" target="_blank" rel="noopener">652-factorization</a></td>
<td>因式分解</td>
<td>dfs+pruning+backtracking</td>
<td>Medium</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>123</td>
<td><a href="https://www.lintcode.com/problem/119/" target="_blank" rel="noopener">119-edit-distance</a></td>
<td>编辑距离</td>
<td>匹配性dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>124</td>
<td><a href="https://www.lintcode.com/problem/787/" target="_blank" rel="noopener">787-the-maze</a></td>
<td>迷宫</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>125</td>
<td><a href="https://www.lintcode.com/problem/788/" target="_blank" rel="noopener">788-the-maze-ii</a></td>
<td>迷宫</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>126</td>
<td><a href="https://www.lintcode.com/problem/789/" target="_blank" rel="noopener">789-the-maze-iii</a></td>
<td>迷宫</td>
<td>bfs</td>
<td>Hard</td>
<td></td>
<td>2020/7/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>127</td>
<td><a href="https://www.lintcode.com/problem/691/" target="_blank" rel="noopener">691-recover-binary-search-tree</a></td>
<td>恢复二叉搜索树</td>
<td>bst</td>
<td>Medium</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>128</td>
<td><a href="https://www.lintcode.com/problem/82/" target="_blank" rel="noopener">82-single-number</a></td>
<td>落单的数2n*1,两次</td>
<td>bit，hash</td>
<td>Easy</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>129</td>
<td><a href="https://www.lintcode.com/problem/83/" target="_blank" rel="noopener">83-single-number-ii</a></td>
<td>落单的数 II 3n*1，三次</td>
<td>bit，hash</td>
<td>Medium</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>130</td>
<td><a href="https://www.lintcode.com/problem/84/" target="_blank" rel="noopener">84-single-number-iii</a></td>
<td>落单的数2*n + 2</td>
<td>bit，hash</td>
<td>Medium</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>131</td>
<td><a href="https://www.lintcode.com/problem/46/" target="_blank" rel="noopener">46-majority-element</a></td>
<td>主元素(不是众数) 1/2</td>
<td>Enumerate</td>
<td>Easy</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>132</td>
<td><a href="https://www.lintcode.com/problem/1018/" target="_blank" rel="noopener">1018-champagne-tower(triangle)</a></td>
<td>香槟塔</td>
<td>二维坐标dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>133</td>
<td><a href="https://www.lintcode.com/problem/200/" target="_blank" rel="noopener">200-longest-palindromic-substring</a></td>
<td>最长回文子串</td>
<td>区间dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>134</td>
<td><a href="https://www.lintcode.com/problem/1565/" target="_blank" rel="noopener">1565-modern-ludo-i</a></td>
<td>飞行棋 I</td>
<td>一维坐标dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>135</td>
<td><a href="https://www.lintcode.com/problem/1141/" target="_blank" rel="noopener">1141-the-months-days</a></td>
<td>月份天数</td>
<td>闰年</td>
<td>Easy</td>
<td></td>
<td>2020/7/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>136</td>
<td><a href="https://www.lintcode.com/problem/254/" target="_blank" rel="noopener">254-drop-eggs</a></td>
<td>丢鸡蛋</td>
<td>归纳法</td>
<td>Easy</td>
<td></td>
<td>2020/7/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>137</td>
<td><a href="https://www.lintcode.com/problem/47/" target="_blank" rel="noopener">47-majority-element-ii</a></td>
<td>主元素1/3</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2020/7/19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>138</td>
<td><a href="https://www.lintcode.com/problem/48/" target="_blank" rel="noopener">48-majority-element-iii</a></td>
<td>主元素1/k</td>
<td>HashTable</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>139</td>
<td><a href="https://www.lintcode.com/problem/150/" target="_blank" rel="noopener">150-best-time-to-buy-and-sell-stock-ii</a></td>
<td>买卖股票的最佳时机 II(多次交易)</td>
<td>贪心</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>140</td>
<td><a href="https://www.lintcode.com/problem/151/" target="_blank" rel="noopener">151-best-time-to-buy-and-sell-stock-iii</a></td>
<td>买卖股票的最佳时机 III(两笔交易)</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>141</td>
<td><a href="https://www.lintcode.com/problem/393/" target="_blank" rel="noopener">393-best-time-to-buy-and-sell-stock-iv</a></td>
<td>买卖股票的最佳时机 III(K笔交易)</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>142</td>
<td><a href="https://www.lintcode.com/problem/44/" target="_blank" rel="noopener">44-minimum-subarray</a></td>
<td>最小子数组</td>
<td>贪心</td>
<td>Easy</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>143</td>
<td><a href="https://www.lintcode.com/problem/45/" target="_blank" rel="noopener">45-maximum-subarray-difference</a></td>
<td>最大子数组差</td>
<td>贪心</td>
<td>Easy</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>144</td>
<td><a href="https://www.lintcode.com/problem/138/" target="_blank" rel="noopener">138-subarray-sum</a></td>
<td>子数组之和</td>
<td>hashmap</td>
<td>Easy</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>145</td>
<td><a href="https://www.lintcode.com/problem/139/" target="_blank" rel="noopener">139-subarray-sum-closest</a></td>
<td>最接近零的子数组和</td>
<td>Two Pointers，hashmap</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>146</td>
<td><a href="https://www.lintcode.com/problem/56/" target="_blank" rel="noopener">56-two-sum</a></td>
<td>两数之和</td>
<td>Two Pointers</td>
<td>Easy</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>147</td>
<td><a href="https://www.lintcode.com/problem/608/" target="_blank" rel="noopener">608-two-sum-ii-input-array-is-sorted</a></td>
<td>两数和 II-输入已排序的数组</td>
<td>Two Pointers</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>148</td>
<td><a href="https://www.lintcode.com/problem/57/" target="_blank" rel="noopener">57-3sum</a></td>
<td>三数之和</td>
<td>Two Pointers</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>149</td>
<td><a href="https://www.lintcode.com/problem/533/" target="_blank" rel="noopener">533-two-sum-closest-to-target</a></td>
<td>两数和的最接近值</td>
<td>Two Pointers</td>
<td>Medium</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>150</td>
<td><a href="https://www.lintcode.com/problem/89/" target="_blank" rel="noopener">89-k-sum</a></td>
<td>K数之和</td>
<td>dp</td>
<td>Hard</td>
<td></td>
<td>2020/7/20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>151</td>
<td><a href="https://www.lintcode.com/problem/140/" target="_blank" rel="noopener">140-fast-power</a></td>
<td>快速幂</td>
<td>DC</td>
<td>Medium</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>152</td>
<td><a href="https://www.lintcode.com/problem/1324/" target="_blank" rel="noopener">1324-count-primes</a></td>
<td>质数的个数</td>
<td>Mathmatics</td>
<td>Easy</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>153</td>
<td><a href="https://www.lintcode.com/problem/141/" target="_blank" rel="noopener">141-sqrtx</a></td>
<td>对x开根</td>
<td>Mathmatics</td>
<td>Easy</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>154</td>
<td><a href="https://www.lintcode.com/problem/2/" target="_blank" rel="noopener">2-trailing-zeros</a></td>
<td>尾部的零</td>
<td>Mathmatics</td>
<td>Easy</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>155</td>
<td><a href="https://www.lintcode.com/problem/142/" target="_blank" rel="noopener">142.o1-check-power-of-2</a></td>
<td>O(1)时间检测2的幂次</td>
<td>Binary</td>
<td>Easy</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>156</td>
<td><a href="https://www.lintcode.com/problem/49/" target="_blank" rel="noopener">49-sort-letters-by-case</a></td>
<td>字符大小写排序</td>
<td>Two Pointers</td>
<td>Medium</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>157</td>
<td><a href="https://www.lintcode.com/problem/1563/" target="_blank" rel="noopener">1563-shortest-path-to-the-destination</a></td>
<td>目的地的最短路径</td>
<td>bfs</td>
<td>Medium</td>
<td></td>
<td>2020/7/21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>158</td>
<td><a href="https://www.lintcode.com/problem/108/" target="_blank" rel="noopener">108-palindrome-partitioning-ii</a></td>
<td>分割回文串 II</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>159</td>
<td><a href="https://www.lintcode.com/problem/107/" target="_blank" rel="noopener">107-word-break</a></td>
<td>单词拆分 I</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>160</td>
<td><a href="https://www.lintcode.com/problem/41/" target="_blank" rel="noopener">41-maximum-subarray</a></td>
<td>最大子数组</td>
<td>dp</td>
<td>Easy</td>
<td></td>
<td>2020/8/3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>161</td>
<td><a href="https://www.lintcode.com/problem/29/" target="_blank" rel="noopener">29-interleaving-string</a></td>
<td>交叉字符串</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>162</td>
<td><a href="https://www.lintcode.com/problem/513/" target="_blank" rel="noopener">513-perfect-squares</a></td>
<td>完美平方</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>163</td>
<td><a href="https://www.lintcode.com/problem/394/" target="_blank" rel="noopener">394-coins-in-a-line</a></td>
<td>硬币排成线</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>164</td>
<td><a href="https://www.lintcode.com/problem/92/" target="_blank" rel="noopener">92-backpack</a></td>
<td>背包问题</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>165</td>
<td><a href="https://www.lintcode.com/problem/118/" target="_blank" rel="noopener">118-distinct-subsequences</a></td>
<td>不同的子序列</td>
<td>dp</td>
<td>Medium</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>166</td>
<td><a href="https://www.lintcode.com/problem/604/" target="_blank" rel="noopener">604-window-sum</a></td>
<td>滑动窗口内数的和</td>
<td>two-pointer</td>
<td>Easy</td>
<td></td>
<td>2020/8/9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>167</td>
<td><a href="https://www.lintcode.com/problem/539/" target="_blank" rel="noopener">539-move-zeroes</a></td>
<td>移动0</td>
<td>two-pointer</td>
<td>Easy</td>
<td></td>
<td>2020/8/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>168</td>
<td><a href="https://www.lintcode.com/problem/521/" target="_blank" rel="noopener">521.remove-duplicate-numbers-in-array</a></td>
<td>数组去重</td>
<td>two-pointer</td>
<td>Easy</td>
<td></td>
<td>2020/8/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>169</td>
<td><a href="https://www.lintcode.com/problem/638/" target="_blank" rel="noopener">638. Isomorphic Strings</a></td>
<td>字符同构</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2021/2/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>170</td>
<td><a href="https://www.lintcode.com/problem/626/" target="_blank" rel="noopener">626. Rectangle Overlap</a></td>
<td>矩形重叠</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2021/2/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>171</td>
<td><a href="https://www.lintcode.com/problem/637/" target="_blank" rel="noopener">637. Valid Word Abbreviation</a></td>
<td>检查缩写单词</td>
<td>string</td>
<td>Easy</td>
<td></td>
<td>2021/2/10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>172</td>
<td><a href="https://www.lintcode.com/problem/639/" target="_blank" rel="noopener">639. Word Abbreviation</a></td>
<td>单词缩写</td>
<td>string</td>
<td>Hard</td>
<td></td>
<td>2021/2/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>173</td>
<td><a href="https://www.lintcode.com/problem/642/" target="_blank" rel="noopener">642. Moving Average from Data Stream</a></td>
<td>数据流滑动窗口平均值</td>
<td>Prefix Sum Array，rolling array</td>
<td>Easy</td>
<td></td>
<td>2021/2/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>174</td>
<td><a href="https://www.lintcode.com/problem/644/" target="_blank" rel="noopener">644. Strobogrammatic Number</a></td>
<td>镜像数字</td>
<td>Enumerate</td>
<td>Easy</td>
<td></td>
<td>2021/2/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>175</td>
<td><a href="https://www.lintcode.com/problem/640/" target="_blank" rel="noopener">640. One Edit Distance</a></td>
<td>一次编辑距离</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>176</td>
<td><a href="https://www.lintcode.com/problem/660/" target="_blank" rel="noopener">660. Read N Characters Given Read4</a></td>
<td>用Read4从文件中读取N个字符 II-多次调用</td>
<td>Enumerate</td>
<td>Hard</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>177</td>
<td><a href="https://www.lintcode.com/problem/659/" target="_blank" rel="noopener">659. Encode and Decode Strings</a></td>
<td>编码和解码字符串</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>178</td>
<td><a href="https://www.lintcode.com/problem/419/" target="_blank" rel="noopener">419. Roman to Integer</a></td>
<td>罗马数字转整数</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>179</td>
<td><a href="https://www.lintcode.com/problem/418/" target="_blank" rel="noopener">418. Integer to Roman</a></td>
<td>整数转罗马数字</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>180</td>
<td><a href="https://www.lintcode.com/problem/645/" target="_blank" rel="noopener">645. Find the Celebrity</a></td>
<td>识别名人</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>181</td>
<td><a href="https://www.lintcode.com/problem/641/" target="_blank" rel="noopener">641. Missing Ranges</a></td>
<td>丢失的间隔</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>182</td>
<td><a href="https://www.lintcode.com/problem/156/" target="_blank" rel="noopener">156. Merge Intervals</a></td>
<td>合并区间</td>
<td>Enumerate</td>
<td>Easy</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>183</td>
<td><a href="https://www.lintcode.com/problem/30/" target="_blank" rel="noopener">30. Insert Interval</a></td>
<td>插入区间</td>
<td>Enumerate</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>184</td>
<td><a href="https://www.lintcode.com/problem/646/" target="_blank" rel="noopener">646. First Position Unique Character</a></td>
<td>第一个不重复字符位置</td>
<td>Hash</td>
<td>Easy</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>185</td>
<td><a href="https://www.lintcode.com/problem/647/" target="_blank" rel="noopener">647. Find All Anagrams in a String</a></td>
<td>子串字谜</td>
<td>Hash+Siding Windows</td>
<td>Medium</td>
<td></td>
<td>2021/2/12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>186</td>
<td><a href="https://www.lintcode.com/problem/423/" target="_blank" rel="noopener">423. Valid Parentheses</a></td>
<td>有效的括号序列</td>
<td>Stack</td>
<td>Easy</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>187</td>
<td><a href="https://www.jiuzhang.com/problem/load-balancer/" target="_blank" rel="noopener">526. Load Balancer</a></td>
<td>负载均衡</td>
<td>DS</td>
<td></td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>188</td>
<td><a href="https://www.lintcode.com/problem/662/" target="_blank" rel="noopener">662. Guess Number Higher or Lower</a></td>
<td>猜数游戏</td>
<td>Binary Search</td>
<td>Easy</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>189</td>
<td><a href="https://www.lintcode.com/problem/661/" target="_blank" rel="noopener">661. Convert BST to Greater Tree</a></td>
<td>把二叉搜索树转化成更大的树</td>
<td>BST</td>
<td>Easy</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>190</td>
<td><a href="https://www.lintcode.com/problem/649/" target="_blank" rel="noopener">649. Binary Tree Upside Down</a></td>
<td>二叉树翻转</td>
<td>BST</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>191</td>
<td><a href="https://www.lintcode.com/problem/650/" target="_blank" rel="noopener">650. Find Leaves of Binary Tree</a></td>
<td>二叉树叶子顺序遍历</td>
<td>BST</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>192</td>
<td><a href="https://www.lintcode.com/problem/651/" target="_blank" rel="noopener">651. Binary Tree Vertical Order Traversal</a></td>
<td>二叉树垂直遍历</td>
<td>Hash+BFS</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>193</td>
<td><a href="https://www.lintcode.com/problem/448/" target="_blank" rel="noopener">448. Inorder Successor in BST</a></td>
<td>二叉查找树的中序后继</td>
<td>BST</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>194</td>
<td><a href="https://www.lintcode.com/problem/477/" target="_blank" rel="noopener">477. Surrounded Regions</a></td>
<td>被围绕的区域</td>
<td>BFS</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>195</td>
<td><a href="https://www.lintcode.com/problem/663/" target="_blank" rel="noopener">663. Walls and Gates</a></td>
<td>墙和门</td>
<td>BFS</td>
<td>Medium</td>
<td></td>
<td>2021/2/13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>196</td>
<td><a href="https://www.lintcode.com/problem/32/" target="_blank" rel="noopener">32. Minimum Window Substring</a></td>
<td>最小子串覆盖</td>
<td>Two pointer</td>
<td>Medium</td>
<td></td>
<td>2021/2/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>197</td>
<td><a href="https://www.lintcode.com/problem/543/" target="_blank" rel="noopener">543. Kth Largest in N Arrays</a></td>
<td>N数组第K大元素(一个数组第<a href="https://www.lintcode.com/problem/5/" target="_blank" rel="noopener">K大</a>)</td>
<td>Heap</td>
<td>Hard</td>
<td></td>
<td>2021/2/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>198</td>
<td><a href="https://www.lintcode.com/problem/465/" target="_blank" rel="noopener">465. Kth Smallest Sum In Two Sorted Arrays</a></td>
<td>两个排序数组和的第K小</td>
<td>Heap</td>
<td>Hard</td>
<td></td>
<td>2021/2/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>199</td>
<td><a href="https://www.lintcode.com/problem/591/" target="_blank" rel="noopener">591. Connecting Graph III</a></td>
<td>连接图 III</td>
<td>UF</td>
<td>Medium</td>
<td></td>
<td>2021/2/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td><a href="https://www.lintcode.com/problem/1179/" target="_blank" rel="noopener">1179. Friend Circles</a></td>
<td>朋友圈</td>
<td>UF</td>
<td>Medium</td>
<td></td>
<td>2021/2/14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>201</td>
<td><a href="https://www.lintcode.com/problem/152/" target="_blank" rel="noopener">152. Combinations</a></td>
<td>组合</td>
<td>DFS，组合</td>
<td>Medium</td>
<td></td>
<td>2021/2/15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>202</td>
<td><a href="https://www.lintcode.com/problem/135/" target="_blank" rel="noopener">135. Combination Sum I</a></td>
<td>组合数之和</td>
<td>DFS，组合</td>
<td>Medium</td>
<td></td>
<td>2021/2/15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>203</td>
<td><a href="https://www.lintcode.com/problem/153/" target="_blank" rel="noopener">153. Combination Sum II</a></td>
<td>组合数之和</td>
<td>DFS，组合</td>
<td>Medium</td>
<td></td>
<td>2021/2/15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>204</td>
<td><a href="https://www.lintcode.com/problem/1321/" target="_blank" rel="noopener">1321. Combination Sum III</a></td>
<td>组合数之和</td>
<td>DFS，组合</td>
<td>Medium</td>
<td></td>
<td>2021/2/15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>205</td>
<td><a href="https://www.lintcode.com/problem/457/" target="_blank" rel="noopener">457. Classical Binary Search</a></td>
<td>经典二分查找问题</td>
<td>Binary Search</td>
<td>Easy</td>
<td></td>
<td>2021/2/15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>206</td>
<td><a href="https://www.lintcode.com/problem/366/" target="_blank" rel="noopener">366. Fibonacci</a></td>
<td>斐波那契</td>
<td>iteration/recursion,多项公式</td>
<td>Naive</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>207</td>
<td><a href="https://www.lintcode.com/problem/1807/" target="_blank" rel="noopener">1807. Fibonacci easy</a></td>
<td>斐波那契</td>
<td>iteration</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>208</td>
<td><a href="https://www.lintcode.com/problem/powx-n/" target="_blank" rel="noopener">428. Pow(x, n)</a></td>
<td>x的n次幂</td>
<td>recursion,decrease-and-conquer</td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>209</td>
<td><a href="https://www.lintcode.com/problem/451/" target="_blank" rel="noopener">451. Swap Nodes in Pairs</a></td>
<td>两两交换链表中的节点</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>210</td>
<td><a href="https://www.lintcode.com/problem/450/" target="_blank" rel="noopener">450. Reverse Nodes in k-Group</a></td>
<td>K组翻转链表</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>211</td>
<td><a href="https://www.lintcode.com/problem/1425/" target="_blank" rel="noopener">1425. Backspace String Compare</a></td>
<td>比较含退格的字符串</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>212</td>
<td><a href="https://www.lintcode.com/problem/5/" target="_blank" rel="noopener">5.Kth Largest Element</a></td>
<td>数组第k大元素</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>213</td>
<td><a href="https://www.lintcode.com/problem/471/" target="_blank" rel="noopener">471. Top K Frequent Words</a></td>
<td>最高频的K个单词</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>214</td>
<td><a href="https://www.lintcode.com/problem/1311/" target="_blank" rel="noopener">1311. Lowest Common Ancestor of a Binary Search Tree</a></td>
<td>二叉搜索树的最近公共祖先</td>
<td></td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>215</td>
<td><a href="https://www.lintcode.com/problem/1509/" target="_blank" rel="noopener">1509. Lemonade Change</a></td>
<td>柠檬水找零</td>
<td>Greedy</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>216</td>
<td><a href="https://www.lintcode.com/problem/1230/" target="_blank" rel="noopener">1230. Assign Cookies</a></td>
<td>分饼干</td>
<td>Greedy</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>217</td>
<td><a href="https://www.lintcode.com/problem/1493/" target="_blank" rel="noopener">1493. Walking Robot Simulation</a></td>
<td>模拟行走机器人</td>
<td>Greedy</td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>218</td>
<td><a href="https://www.lintcode.com/problem/155/" target="_blank" rel="noopener">155. Minimum Depth of Binary Tree</a></td>
<td>二叉树的最小深度</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>219</td>
<td><a href="https://www.lintcode.com/problem/1360/" target="_blank" rel="noopener">1360. Symmetric Tree</a></td>
<td>对称树</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>220</td>
<td><a href="https://www.lintcode.com/problem/1244/" target="_blank" rel="noopener">1244. Minimum Genetic Mutation</a></td>
<td>最小基因变化</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>221</td>
<td><a href="https://www.lintcode.com/problem/427/" target="_blank" rel="noopener">427. Generate Parentheses</a></td>
<td>生成括号</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>222</td>
<td><a href="https://www.lintcode.com/problem/1195/" target="_blank" rel="noopener">1195. Find Largest Value in Each Tree Row</a></td>
<td>找出树中每行的最大值</td>
<td></td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>223</td>
<td><a href="https://www.lintcode.com/problem/120/" target="_blank" rel="noopener">120. Word Ladder</a></td>
<td>单词接龙</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>224</td>
<td><a href="https://www.lintcode.com/problem/615/" target="_blank" rel="noopener">615. Course Schedule</a></td>
<td>课程表</td>
<td></td>
<td></td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>225</td>
<td><a href="https://www.lintcode.com/problem/1189/" target="_blank" rel="noopener">1189. Minesweeper</a></td>
<td>扫雷游戏</td>
<td>BFS</td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>226</td>
<td><a href="https://www.lintcode.com/problem/389/" target="_blank" rel="noopener">389. Valid Sudoku</a></td>
<td>判断数独是否合法</td>
<td>Simulation</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>227</td>
<td><a href="https://www.lintcode.com/problem/123/" target="_blank" rel="noopener">123. Word Search</a></td>
<td>单词搜索</td>
<td>DFS</td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>228</td>
<td><a href="https://www.lintcode.com/problem/664/" target="_blank" rel="noopener">664. Counting Bits</a></td>
<td>数 1</td>
<td>Bit，DP</td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>229</td>
<td><a href="https://www.lintcode.com/problem/maximum-product-subarray/" target="_blank" rel="noopener">191. Maximum Product Subarray</a></td>
<td>乘积最大子序列</td>
<td>线性dp</td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>230</td>
<td><a href="https://www.lintcode.com/problem/556/" target="_blank" rel="noopener">556. Standard Bloom Filter</a></td>
<td>标准型布隆过滤器</td>
<td></td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>231</td>
<td><a href="https://www.lintcode.com/problem/555/" target="_blank" rel="noopener">555. Counting Bloom Filter</a></td>
<td>计数型布隆过滤器</td>
<td></td>
<td>Medium</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>232</td>
<td><a href="https://www.lintcode.com/problem/1332/" target="_blank" rel="noopener">1332. Number of 1 Bits</a></td>
<td>判断一个整数中有多少个1</td>
<td>Bit</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>233</td>
<td><a href="https://www.lintcode.com/problem/204/" target="_blank" rel="noopener">204. Singleton</a></td>
<td>单例</td>
<td>OOD</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>234</td>
<td><a href="https://www.lintcode.com/problem/496/" target="_blank" rel="noopener">496. Toy Factory</a></td>
<td>工厂</td>
<td>OOD</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>235</td>
<td><a href="https://www.lintcode.com/problem/175/" target="_blank" rel="noopener">175. Invert Binary Tree</a></td>
<td>反转二叉树</td>
<td>Tree</td>
<td>Easy</td>
<td></td>
<td>2021/2/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
        <category>面试算法</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>COSEA模型:软件系统模型的探索(1)</title>
    <url>/2022/10/30/system-research-template/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>系统研究，首先需要还原论，然后是系统论。<strong>还原论</strong>把系统进行拆解，对每一部分进行深入研究，相对静态，<strong>系统论</strong>将每一部分进行整合，形成整体，与外部进行交互，相对动态。如<strong>《庄子 · 养生主第三》庖丁解牛所言：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行”</strong>。研究递进层次和生物学类似，从细胞（源码）-&gt;组织（包）-&gt;器官（功能）-&gt;系统（模块）-&gt;人体（软件）-&gt; 生态（生态圈）。本文主要探讨了对软件系统的研究模型，模型对技术选型，体系化认知，以及更进一步学习技术有帮助。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p><img src="/images/System-Reasearch.png" alt="任务结构"></p>
<p><strong>COSEA</strong>模型是软件系统模型，全称 C：Config配置，O：Operation运维，S：System系统，E：Ecosystem生态，A：Admin管理。</p>
<p>模型回答了一个核心问题：<strong>如何研究软件系统？</strong></p>
<p>模型给出的答案是：从配置C，运维O，系统S，生态E，管理A这五个角度研究软件系统。</p>
<p>黄色方框是五个最重要的因素，层级较高，蓝色方框是对五个因素的分解。总而言之：<strong>配置和运维影响系统，而系统会产生生态和管理</strong>。字母<strong>顺序</strong>也暗含了，先配置，后运维（安装），然后系统跑起来，然后产生管理和生态。</p>
<h2 id="Config-配置"><a href="#Config-配置" class="headerlink" title="Config:配置"></a>Config:配置</h2><p>服务器配置，客户端配置等，理解配置对于<strong>理解</strong>系统，以及系统<strong>调优</strong>非常重要，很多系统概念都在配置中体现，系统的<strong>权衡</strong>也在配置中体现，需要精通最<strong>常用</strong>的配置。很多时候，调优的一大部分其实是改配置。配置分为<strong>操作系统层</strong>的<strong>CPU（线程数），内存（虚拟内存），网络，磁盘</strong>，以及<strong>系统层</strong>的优化。系统层和操作系统层互相影响。借助操作系统实现系统本身的，操作系统配置非常重要。系统层配置也通过<strong>分形原则</strong>到达了操作系统层。通用配置有：压缩算法选择，磁盘读取/写入，缓存，线程。</p>
<h2 id="Operation-运维"><a href="#Operation-运维" class="headerlink" title="Operation:运维"></a>Operation:运维</h2><p>运维包括维护，安装，备份，硬件，安全，部署。包括常用命令，线上配置等。</p>
<h2 id="System-系统"><a href="#System-系统" class="headerlink" title="System:系统"></a>System:系统</h2><p>系统是软件本身，包括<strong>架构</strong>和<strong>功能</strong>，架构包括设计和实现，功能有读写功能，以及业务代码编写等。系统架构回答的基本问题是：<strong>读写流程是什么？以及启动流程？</strong>功能和架构相互影响的是单机和分布式。<strong>单机特性</strong>有：数据模型，存储模型，读写性能，启动流程等，<strong>分布式特性</strong>有：<strong>用户视角</strong>：读/写(增删改查)路径，启动/关闭过程，<strong>系统视角</strong>：一致性模型，复制，分区，共识，容错。复制，共识，分区等等细节都会在用户读写路径视角展现。而系统视角具有通用性的，可以和其他系统进行<strong>类比</strong>，也可以更深一步分析（CAP，PACELC等）。系统核心是：<strong>内部实现，外部交互，系统属性</strong>。总结如下：</p>
<ul>
<li>内部实现，外部交互，系统属性。</li>
<li>单机特性（对标数据库）<ul>
<li>数据模型，存储模型，查询模型（读写性能）</li>
</ul>
</li>
<li>分布式特性（对标分布式系统）<ul>
<li>用户视角：读写路径，启动/关闭。</li>
<li>系统视角：复制和一致性，容错，分区，共识。</li>
</ul>
</li>
</ul>
<h2 id="Ecosystem-生态"><a href="#Ecosystem-生态" class="headerlink" title="Ecosystem:生态"></a>Ecosystem:生态</h2><p>生态是围绕该软件的工具链，培训，开源社区，公司，客户，基金会，出版书籍，论文，创始人履历等等。</p>
<h2 id="Admin-管理"><a href="#Admin-管理" class="headerlink" title="Admin:管理"></a>Admin:管理</h2><p>管理主要是监控，包括管理控制台，主要判断系统是否健康，以及内部状态统计等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同角色关注系统点不一样，想要全面了解系统，以上所有点均需要学习，不求甚解，对系统形成完整认识。本文虽然在讲系统，但是抽象层次还是较低，不够通用，但较为实用。</p>
]]></content>
      <categories>
        <category>模型</category>
        <category>软件模型</category>
      </categories>
      <tags>
        <tag>软件系统模型</tag>
        <tag>创造</tag>
        <tag>COSEA策略</tag>
      </tags>
  </entry>
  <entry>
    <title>微信支付公私钥加解密流程</title>
    <url>/2021/07/22/wechat-pay/</url>
    <content><![CDATA[<p><img src="/images/wechat-pay.png" alt="p3c"></p>
<p>微信支付完整流程如下：</p>
<p>发送方: 私钥签名 公钥加密</p>
<p>接收方: 私钥解密 公钥验签</p>
<p>签名规则：私钥签名，公钥验签。</p>
<p>1 <strong>商户私钥签名</strong>，保证数据商户签名，<strong>微信公钥加密</strong>对原文和签名，得到纯密文，保证商户数据只能由微信私钥解密。</p>
<p>2 <strong>微信私钥解密</strong>，得到商户发送的原数据和签名，用<strong>商户公钥验签</strong>，保证是商户发送的数据。</p>
<p>3 <strong>微信私钥签名</strong>，保证返回值是微信的返回值，用<strong>商户公钥加密</strong>，保证微信返回值只能由商户私钥解密。</p>
<p>4 <strong>商户私钥解密</strong>，得到微信发送的返回值和签名，然后<strong>微信公钥验签</strong>，保证是微信返回的数据。</p>
<h3 id="openssl生成证书命令"><a href="#openssl生成证书命令" class="headerlink" title="openssl生成证书命令"></a>openssl生成证书命令</h3><p>openssl x509 -outform der -in your-cert.pem -out your-cert.crt</p>
<p>openssl genrsa -out ca.key.pem 2048</p>
<p>openssl req -new -key ca.key.pem -out ca.csr</p>
<p>openssl x509 -req -days 1000 -signkey ca.key.pem -in ca.csr -out ca.cer</p>
<p>openssl genrsa -out ca.key.pem 2048</p>
<p>openssl req -new -key ca.key.pem -out ca.csr</p>
<p>openssl x509 -req -days 1000 -signkey ca.key.pem -in ca.csr -out ca.cer</p>
<p>openssl pkcs12  -export -cacerts -inkey ca.key.pem -in ca.cer ca.p12</p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>公私钥</tag>
        <tag>RSA算法</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用消息队列？</title>
    <url>/2024/03/02/why-choose-mq/</url>
    <content><![CDATA[<h1 id="必言利"><a href="#必言利" class="headerlink" title="必言利"></a>必言利</h1><p>消息队列作为核心中间件被广泛使用于应用系统，可是我们为什么要使用它呢？</p>
<p>当然是它能带来好处，一般所认为好处有：</p>
<ol>
<li>提高系统稳定性。A，B系统不一定同时在线，或系统故障，或系统属性，所以需要临时数据存储地方，比如邮箱系统。</li>
<li>提高系统伸缩性。这个是分布式系统带来的能力，分布式的消息队列也能带来这些能力。</li>
<li>异步化处理。同步处理太慢，或者没办法同步处理（对方系统不在线）时候，异步化处理能保证系统最终处理。消息队列可以异步化处理，但是异步化不是消息队列。</li>
<li>削峰填谷。在流量大的时候，通过消息队列暂时处理请求，让系统慢慢处理。</li>
<li>系统间信息传递。比如ETL，作为系统间的桥梁进行数据交换。</li>
<li>解耦。A系统发送N个消息给B系统，C系统，B要发系统给C，A等等，那么会导致系统耦合性很高，不如发送给一个中间节点，让接收方来订阅消息。</li>
</ol>
<p>上面6条均是消息队列所带来的好处，但是不够言简意赅，因为有些是功能带来的，有些是队列本身带来的，有些互为因果，我觉得根本在于：</p>
<ol>
<li><strong>系统层面</strong>来看，它解决了系统处理速度的不同。</li>
<li><strong>数据层面</strong>来看，它解决了动态数据管理问题。</li>
</ol>
<h1 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h1><p>消息队列是一种有界缓冲区（Bounded buffer），用来处理系统间速度不一致。正是因为速度不一样，某个系统/操作明显很慢，所以需要缓冲区来进行处理。比如异步化处理时候，或者削峰填谷，均是系统间速度差异导致的问题，理想情况系统产生数据直接完美存入数据库，但是数据库处理能力跟不上。请求量过大，系统本身也可能处理不了，所以需要外部系统暂时存下，等后续有时间再处理。解耦只要引入第三方系统，都能解耦，所以不是消息队列带来的，而是消息队列对解耦处理的更好，比如发布订阅机制。</p>
<p>这里强调系统间速度，而不是单一系统速度，比如MySQL写入慢，暂时存在Redis，这是单一系统问题，不是系统间的速度问题。</p>
<h1 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h1><p>消息队列管理动态数据，数据库管理静态数据。从数据角度来看，所有系统最终都会产生数据，数据量可大可小，小的时候数据系统能承受，数据太大，数据系统承受不了，流动的数据过多，欲要静止而不可，动静转换，均是数据形态。动转静，静转动，消息队列均可。ETL本身也是管理动态数据的方法。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>消息队列能带来很多好处，有时候需要的并不是消息队列，而是需要判断当前系统的问题。在如今各种开源软件功能越来越全面时候，一个KV系统做的和消息系统类似，甚至提供了比消息系统更多的功能，系统间的边界越来越模糊，消息队列的<strong>简单选择考量因素</strong>却被淹没在很多似是而非的言论中，在我看来，<strong>系统层面系统间的速度问题</strong>和<strong>数据层面动态管理问题</strong>是我要选择消息队列的重要考量因素，当明白了关键问题后，对待各种具体产品可以做到游刃有余。</p>
]]></content>
      <categories>
        <category>技术选型</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成之实践单元测试</title>
    <url>/2020/12/02/unit-test/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><strong>单元测试</strong>是保证质量，降低风险的一种重要工具。但是独立的单元测试本身意义不大，但是整合在CI使之成为<strong>自动化测试</strong>中就会体现其价值，这是一个价值流的传递过程，每一个过程传递软件质量和风险的信息。高质量的代码是<strong>CLEAN</strong>的并且<strong>易测试</strong>的，C(Cohesive内聚)，L(Loosely Couped松散耦合) E(Encapsulated 封装) Assertive(自主) Nonredundant(无冗余)，但是单元测试又是怎么影响这些特性的呢？</p>
<p><strong>Design</strong>：如果我的代码很难测试，那么对客户端来说设计不佳。</p>
<p><strong>Cohesive</strong>：如果需要为一个类编写很多测试，就会意识到内聚性不足。</p>
<p><strong>Loosely Couped</strong>：如果我的测试有很多无关的依赖，那么一定是耦合过多了。 </p>
<p><strong>Encapsulated</strong>：如果我的测试依赖于实现细节，那么肯定是封装出现了问题。</p>
<p><strong>Assertive</strong>：如果测试结果在被测对象以外对象中体现，我的对象可能不够自主。</p>
<p><strong>Nonredundant</strong>：如果我一遍一遍编写同样的测试，那肯定出现了冗余。</p>
<p>一个常规的CI流程如下：</p>
<img src="/images/CI.png" style="zoom:80%;" />

<p>从编译源码-》持续集成数据库-》持续测试-》持续审查-》持续部署-》持续反馈，我们在编译源码和持续部署做的很好，但是在改进质量并降低风险的<strong>持续测试</strong>和<strong>持续审查</strong>做的不好，导致软件质量差，代码烂，重复率高。本文主要对持续测试中的单元测试作为实战基础来讲解一个例子，因为这是一个起点，虽然单独通过<strong>持续审查</strong>也能提高质量，但是由于业务压力和人员变更使得代码变乱，光靠审查无法为迭代的业务提供持续的重构保证，也无法自动化基础设施。</p>
<h1 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h1><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><p>单元测试框架<a href="https://junit.org/junit5/" target="_blank" rel="noopener">junit5</a>，mock框架<a href="https://site.mockito.org/" target="_blank" rel="noopener">mockito</a>，断言框架<a href="https://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">assertj</a> </p>
<h2 id="案例一-使用Mock取代依赖"><a href="#案例一-使用Mock取代依赖" class="headerlink" title="案例一:使用Mock取代依赖"></a>案例一:使用Mock取代依赖</h2><p>以下这段代码即调用了Redis，也调用了第三方接口，还调用了数据库，是一个比较综合的案例，我们来一起看看如何将他变成方便测试的代码，并且保证如何通过单元测试达到覆盖率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskCenterWithdrawServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskCenterWithdrawService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpEncryptDecryptEngine remote;<span class="comment">//调用第三方</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WithdrawService withdrawService;<span class="comment">//关联DB</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWithdraw</span><span class="params">(String coinSymbol, String walletSymbol, String appId,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TransactionWithdrawCrypto twc)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TransactionWithdrawCrypto withdrawCrypto = withdrawService.selectByIdAndLock(twc.getId());<span class="comment">//查询数据库</span></span><br><span class="line">        String payload = generateWithdrawRequest(coinSymbol, walletSymbol, withdrawCrypto);<span class="comment">//构造请求参数，里面查询静态方法</span></span><br><span class="line">        String result = remote.startWithdraw(appId, payload);<span class="comment">//调用第三方接口返回结果</span></span><br><span class="line">        WalletResponseCode responseCode = WalletResponseCode.ofCode(result);</span><br><span class="line">        <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WITHDRAW_ADDR_ERROR:</span><br><span class="line">            <span class="keyword">case</span> WITHDRAW_CANNOT_TO_SELF: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    withdrawService.cancelWithdraw();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"startWithdrawRequest cancel withdrawCrypto id : &#123;&#125; error "</span>,</span><br><span class="line">                              withdrawCrypto.getId(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">default</span>:                </span><br><span class="line">                cancelWithdrawIfAdminConfiged(withdrawCrypto.getId(), responseCode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateWithdrawRequest</span><span class="params">(String coinSymbol, String walletSymbol,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TransactionWithdrawCrypto c)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//......里面查询了redis</span></span><br><span class="line">    ConfigCoinSymbol c = CoinSymbolUtils.getSaaSInfo(coinSymbol);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> ....;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们看到这个代码，需要思考测试什么才能证明代码没有错呢？既当什么情况下，你期望发生什么。来看看我们得期望：</p>
<p>1   当第三方接口返回成功时候，该方法结束。</p>
<p>2   当第三方接口返回WITHDRAW_ADDR_ERROR或者WITHDRAW_CANNOT_TO_SELF，我们需要调用cancelWithdraw，</p>
<p>3   当第三方接口返回其他情况时候，调用cancelWithdrawIfAdminConfiged方法。</p>
<p>4   当传入不同币种的时候，generateWithdrawRequest产生不同的请求。</p>
<p>我们仅仅需要验证这些就够了，因为TaskCenterWithdrawServiceImpl得协作者的产生的行为仅仅如此，至于协作者行为的可靠性，需要协作者自身去验证，而不是在该测试中验证。</p>
<h3 id="第一步-依赖注入解耦"><a href="#第一步-依赖注入解耦" class="headerlink" title="第一步 依赖注入解耦"></a>第一步 依赖注入解耦</h3><p>spring字段注入导致单元测试困难，因为你无法实例化类中的对象，所以在TaskCenterWithdrawServiceImpl中将字段注入改成构造器注入或者属性注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskCenterWithdrawServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WithdrawService withdrawService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpEncryptDecryptEngine</span><span class="params">(HttpEncryptDecryptEngine httpEncryptDecryptEngine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpEncryptDecryptEngine = httpEncryptDecryptEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWithdrawService</span><span class="params">(WithdrawService withdrawService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.withdrawService = withdrawService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="第二步-静态方法抽离接口"><a href="#第二步-静态方法抽离接口" class="headerlink" title="第二步 静态方法抽离接口"></a>第二步 静态方法抽离接口</h3><p>不是所有静态方法都需要抽离成接口，由于项目中CoinSymbolUtils.getSaaSInfo调用了数据库和redis，所以此时你无法真实调用数据库和redis，因为在脱离spring环境你无法创建这两个对象，所以抽离成接口可以mock改接口。如果是普通的工具类，让他执行即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoinSymbolOperator</span> </span>&#123;</span><br><span class="line">    <span class="function">ConfigCoinSymbol <span class="title">getSaaSInfoAll</span><span class="params">(String coinSymbol)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前工具类实现该接口，并且调用之前静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinSymbolUtils</span> <span class="keyword">implements</span>  <span class="title">CoinSymbolOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConfigCoinSymbol <span class="title">getSaaSInfoAll</span><span class="params">(String coinSymbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSaaSInfo(coinSymbol);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第三步-测试mock对象"><a href="#第三步-测试mock对象" class="headerlink" title="第三步 测试mock对象"></a>第三步 测试mock对象</h3><p>mock对象我们使用的是<strong>mockito</strong>框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskCenterWithdrawServiceMockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//待测试的类</span></span><br><span class="line">    <span class="keyword">private</span> TaskCenterWithdrawServiceImpl taskCenterWithdrawService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WithdrawService withdrawService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoinSymbolOperator coinSymbolOperator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建TaskCenterWithdrawService对象</span></span><br><span class="line">    httpEncryptDecryptEngine = mock(HttpEncryptDecryptEngine<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    withdrawService = mock(WithdrawService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//mock静态方法拆离的接口在这里需要注入到TaskCenterWithdrawService中</span></span><br><span class="line">    coinSymbolOperator = mock(CoinSymbolOperator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    taskCenterWithdrawService = <span class="keyword">new</span> <span class="keyword">new</span> TaskCenterWithdrawServiceImpl();</span><br><span class="line">    taskCenterWithdrawService.setHttpEncryptDecryptEngine(httpEncryptDecryptEngine);</span><br><span class="line">    taskCenterWithdrawService.setWithdrawService(withdrawService);</span><br><span class="line">    taskCenterWithdrawService.setCoinSymbolOperator(coinSymbolOperator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第四步-编写测试方法"><a href="#第四步-编写测试方法" class="headerlink" title="第四步 编写测试方法"></a>第四步 编写测试方法</h3><p>测试方法必须要写assertions和你要验证的东西，否则这个单元测试没有意义。这个测试没有用到<strong>assertj</strong>  ，而是使用了<strong>mockito</strong>自带的verify方法验证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWithdraw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//given willReturn 短语帮助我们构造期望的输入和输出，含义是当满足xxx条件时候，发生什么，期望什么结果。</span></span><br><span class="line">    <span class="comment">//当给getWalletUid传入任意int和string时候，调用cryptoAddressService.getWalletUid，期望返回123</span></span><br><span class="line">    given(cryptoAddressService.getWalletUid(anyInt(), anyString())).willReturn(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造期望的返回值</span></span><br><span class="line">    TransactionWithdrawCrypto transactionWithdrawCrypto = <span class="keyword">new</span> TransactionWithdrawCrypto();</span><br><span class="line">    transactionWithdrawCrypto.setAddressFrom(<span class="string">"alibaba"</span>);</span><br><span class="line">    transactionWithdrawCrypto.setFee(<span class="keyword">new</span> BigDecimal(<span class="string">"456.777"</span>));</span><br><span class="line">    transactionWithdrawCrypto.setSymbol(<span class="string">"USDT"</span>);</span><br><span class="line">    transactionWithdrawCrypto.setAddressTo(<span class="string">"baidu"</span>);</span><br><span class="line">    transactionWithdrawCrypto.setUid(<span class="number">111111111</span>);</span><br><span class="line"></span><br><span class="line">    transactionWithdrawCrypto.setAmount(<span class="keyword">new</span> BigDecimal(<span class="string">"123.444"</span>));</span><br><span class="line">    <span class="comment">//构造期望输入和输出</span></span><br><span class="line">    given(withdrawService.selectByIdAndLock(anyInt())).willReturn(transactionWithdrawCrypto);</span><br><span class="line"></span><br><span class="line">    ConfigCoinSymbol ccs = <span class="keyword">new</span> ConfigCoinSymbol();</span><br><span class="line">    ccs.setTokenBase(<span class="string">"BTC"</span>);</span><br><span class="line">    ccs.setContractAddress(<span class="string">"BTC_ContractAddress"</span>);</span><br><span class="line">    <span class="comment">//构造期望输入和输出</span></span><br><span class="line">    given(coinSymbolOperator.from(<span class="string">"USDT"</span>)).willReturn(ccs);</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="string">"code"</span>, WalletResponseCode.SUCCESS.getCode());</span><br><span class="line">    result.put(<span class="string">"message"</span>, WalletResponseCode.SUCCESS.getMessage());</span><br><span class="line">    <span class="comment">//构造期望输入和输出</span></span><br><span class="line">    given(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).willReturn(JSON.toJSONString(result));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和given，willReturn一样的效果</span></span><br><span class="line">    <span class="comment">//when(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).thenReturn("111111111");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这一步是将之前mock的对象和数据以及构造期望输入和输出串联起来执行。</span></span><br><span class="line">    taskCenterWithdrawService.startWithdraw(<span class="string">"USDT"</span>, <span class="string">"BTC"</span>, <span class="string">"aaaa"</span>, <span class="keyword">new</span> TransactionWithdrawCrypto());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于该方法是void所以需要验证方法是否被调用.比如断言getWalletUid是否被调用，比如第三方接口返回值不同调用不同的方法</span></span><br><span class="line">    <span class="comment">//来使得代码覆盖率比较高</span></span><br><span class="line">    verify(<span class="keyword">this</span>.cryptoAddressService).getWalletUid(<span class="number">111111111</span>, <span class="string">"BTC"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例二：关联数据库的单元测试"><a href="#案例二：关联数据库的单元测试" class="headerlink" title="案例二：关联数据库的单元测试"></a>案例二：关联数据库的单元测试</h2><p>有些测试必须关联数据库或者第三方接口，此时不得不接受使用外部资源这一现实。这时候测试关联数据库的必须保证测试前数据库状态和测试后状态一致。我们来建立一个test fixture来验证一个CRUD的正确性。在每个方法执行前用@BeforeEach中建立Account对象，在integrateTestDataBaseCRUD中测试CRUD方法，在每个方法结束后用@AfterEach清除数据库对象，使得测试前后数据库状态幂等。我曾经遇到一个必须使用第三方资源场景是 本地代码必须调用第三方接口来验证程序，以及在集成测试时候，也主要验证第三方接口，程序本身逻辑很少。这时候就必须使用外部依赖来完成单元测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        account = Account.builder().</span><br><span class="line">                balance(<span class="keyword">new</span> BigDecimal(<span class="string">"67.88"</span>)).</span><br><span class="line">                type(<span class="number">111</span>).</span><br><span class="line">                uid(<span class="number">445</span>).</span><br><span class="line">                tag(<span class="string">"33"</span>).</span><br><span class="line">                build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">integrateTestDataBaseCRUD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.insert(account);</span><br><span class="line">        <span class="keyword">long</span> id = account.getId();</span><br><span class="line">        Account accountFind = accountService.get(id);</span><br><span class="line">        accountFind.setBalance(<span class="keyword">new</span> BigDecimal(<span class="string">"366334"</span>));</span><br><span class="line">        accountService.update(accountFind);</span><br><span class="line">        Account accountUpdate = accountService.get(id);</span><br><span class="line">        accountService.delete(id);</span><br><span class="line">        Account accountDelete = accountService.get(id);</span><br><span class="line"></span><br><span class="line">        assertAll(<span class="string">"test"</span>, () -&gt; &#123;</span><br><span class="line">            assertEquals(accountFind.getBalance().stripTrailingZeros().toPlainString(),</span><br><span class="line">                    accountUpdate.getBalance().stripTrailingZeros().toPlainString());</span><br><span class="line">        &#125;);</span><br><span class="line">        assertNull(accountDelete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看到上述两个案例都是先写代码后写单元测试，这样可能导致单元测试很难测试代码，给遗留系统添加单元测试也很繁琐，所以需要从设计层面改进代码，使之更加容易测试和验证。更优秀的做法是实践TDD，这样代码天然可测试。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>1 单元测试的价值在哪里？</strong> 1  保证代码质量，当然质量保证不仅仅靠单元测试。当你看到队友提交了一些代码，确发现单元测试覆盖率降低了，就知道他的提交可能带来代码质量下降。 2  代码可测试性往往带来灵活的设计。  3  你不仅仅在写单元测试，而是实践自动化测试，实践着CI </p>
<p><strong>2  遗留系统很多没有单元测试，我需要补吗？</strong>1  当你修改老代码的时候，加一个单元测试。 2 依赖最多的，访问最多的需要补充。 3 试图在遗留系统上加单元测试很困难，并且使之成为自动化测试，但是需要尝试，新的代码尝试TDD。</p>
<p><strong>3  我觉得有些情况需要读取数据库，看到数据落库心里才踏实，这时候写单元测试需要连数据库吗？</strong>单元测试不连库，连库的叫集成测试，单元测试验证是逻辑，数据库只是细节实现，你的代码可以脱离SSM，MySQL….. 在实践中你会真正理解解耦的。你的踏实和自信应该建立在独立性和不依赖外界细节上，而不是数据归属地到底是哪里。如果一些测试必须要用数据库，请使用test fixture。保证单元测试前和单元测试后数据库状态一致。</p>
<p><strong>4  什么时候用Mock或者Stub？</strong> 能不用就不用，最简单的方式验证你的代码是否正确。</p>
<p><strong>5  DAO层的实体对象需要手动new吗？</strong> 取决于你验证的是什么。随着积累会建立实体对象的测试仓库。</p>
<p><strong>6  单元测试能检测什么类型bug？</strong> 测不出与数据库交互和第三方接口的BUG，这不是单元测试职责，但是你可以在单元测试中调用第三方，然后发布时候@Disable该测试即可。</p>
<p><strong>7 为什么不用junit自带的断言，而是第三方断言？</strong> junit断言可读性不好，而且需要自己写断言逻辑，assertXXX，而assertj里面assertThat可以方便断言和真正验证的东西相匹配。</p>
<p><strong>8 先写测试还是先写代码？</strong> 先写测试的系统天然适合自动化测试，先写代码在写测试，极大可能不写测试了。</p>
<p>这些只是个人观点，实践过程有更好的方法或者理解，可以推翻。单元测试价值不应该被夸大，但也不该被忽视。它是能提高设计和质量的重要工具，因为相信，所以看见。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul>
<li>《测试驱动开发》</li>
<li>《持续集成-软件质量改进和风险降低之道》</li>
</ul>
]]></content>
      <categories>
        <category>持续集成</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
</search>
